import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
    Box,
    Drawer,
    IconButton,
    Typography,
    Tooltip,
    Divider,
    useTheme,
    useMediaQuery,
    TextField,
    Button,
    Checkbox,
    FormControlLabel,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Select,
    MenuItem,
    FormControl
} from '@mui/material';
import { toast } from 'react-toastify';
import { 
    normalizeQuestionNumber, 
    checkForDuplicateQuestionNumber, 
    parseQuestionNumberForSorting 
} from '../../utils/questionNumberValidation';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import VisibilityIcon from '@mui/icons-material/Visibility';
import DragIndicatorIcon from '@mui/icons-material/DragIndicator';
import EditIcon from '@mui/icons-material/Edit';
import SaveIcon from '@mui/icons-material/Save';
import CancelIcon from '@mui/icons-material/Cancel';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import {
    DndContext,
    closestCenter,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
    DragEndEvent,
} from '@dnd-kit/core';
import {
    arrayMove,
    SortableContext,
    sortableKeyboardCoordinates,
    verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import {
    useSortable,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

interface FlowPreviewDrawerProps {
    nodes: any[];
    edges: any[];
    isOpen: boolean;
    onToggle: () => void;
    onUpdateNode?: (nodeId: string, updates: any) => void;
    onDeleteNode?: (nodeId: string) => void;
    onAddNode?: (afterNodeId?: string, questionData?: any) => void;
    onUpdateEdges?: (newEdges: any[]) => void;
    isSplitScreen?: boolean;
    onSplitScreenToggle?: () => void;
    showStartDialog?: boolean; // Add prop to control visibility when StartDialog is showing
}

// Sortable Option Component
interface SortableOptionProps {
    id: string;
    option: string;
    optionIndex: number;
    nodeId: string;
    optionData: any;
    isYesNo?: boolean;
    editingOption: { nodeId: string; optionIndex: number } | null;
    editingReferralText: { nodeId: string; optionIndex: number } | null;
    editValues: { question?: string; options?: string[]; responses?: string[] };
    onStartEditingOption: (nodeId: string, optionIndex: number) => void;
    onSaveOption: (nodeId: string) => void;
    onCancelEdit: () => void;
    onDeleteOption: (nodeId: string, optionIndex: number) => void;
    onSaveReferralText: (nodeId: string, optionIndex: number, text: string) => void;
    onSetEditingReferralText: (nodeId: string, optionIndex: number) => void;
    onUpdateNode: (nodeId: string, updates: any) => void;
    onConnectionChange: (sourceNodeId: string, optionIndex: number, newTarget: string) => void;
    onGetCurrentConnection: (nodeId: string, optionIndex: number) => string;
    onGetAvailableQuestions: (nodeId: string) => Array<{ value: string; label: string }>;
    nodes: any[];
}

const SortableOption: React.FC<SortableOptionProps> = ({
    id,
    option,
    optionIndex,
    nodeId,
    optionData,
    isYesNo = false,
    editingOption,
    editingReferralText,
    editValues,
    onStartEditingOption,
    onSaveOption,
    onCancelEdit,
    onDeleteOption,
    onSaveReferralText,
    onSetEditingReferralText,
    onUpdateNode,
    onConnectionChange,
    onGetCurrentConnection,
    onGetAvailableQuestions,
    nodes
}) => {
    const {
        attributes,
        listeners,
        setNodeRef,
        transform,
        transition,
        isDragging,
    } = useSortable({ id });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.5 : 1,
    };

    const isEditing = editingOption?.nodeId === nodeId && editingOption?.optionIndex === optionIndex;
    const isEditingReferral = editingReferralText?.nodeId === nodeId && editingReferralText?.optionIndex === optionIndex;

    return (
        <Box
            ref={setNodeRef}
            style={style}
            sx={{
                display: 'grid',
                gridTemplateColumns: {
                    xs: '1fr auto auto',
                    sm: '2fr 1fr auto',
                    md: '2fr 1fr 80px'
                },
                alignItems: 'center',
                padding: '4px 0',
                fontSize: { xs: '12px', sm: '14px' },
                color: '#333',
                gap: { xs: 1, sm: 2 },
                backgroundColor: isDragging ? '#f5f5f5' : 'transparent',
                borderRadius: isDragging ? '4px' : '0',
                border: isDragging ? '1px dashed #ccc' : 'none',
            }}
        >
            {/* Option Text - Left Side */}
            <Box sx={{
                display: 'flex',
                alignItems: 'center',
                gap: 0.5,
                flex: 1,
                wordBreak: 'break-word',
                overflow: 'hidden'
            }}>
                {/* Drag Handle */}
                <Box
                    {...attributes}
                    {...listeners}
                    sx={{
                        cursor: 'grab',
                        display: 'flex',
                        alignItems: 'center',
                        padding: '2px',
                        '&:hover': {
                            backgroundColor: '#f0f0f0',
                            borderRadius: '2px'
                        }
                    }}
                >
                    <DragIndicatorIcon 
                        sx={{ 
                            fontSize: '16px', 
                            color: '#999',
                            '&:hover': { color: '#666' }
                        }} 
                    />
                </Box>

                {isEditing ? (
                    // Editable option
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5, flex: 1 }}>
                        <Box sx={{
                            minWidth: { xs: '16px', sm: '20px' },
                            fontWeight: 'bold',
                            marginRight: { xs: '4px', sm: '8px' },
                            fontSize: { xs: '11px', sm: '14px' }
                        }}>
                            {optionIndex + 1}.
                        </Box>
                        <TextField
                            value={editValues.options?.[optionIndex] || ''}
                            onChange={(e) => {
                                const newOptions = [...(editValues.options || [])];
                                newOptions[optionIndex] = e.target.value;
                                // This will be handled by the parent component's setEditValues
                            }}
                            variant="outlined"
                            size="small"
                            sx={{
                                flex: 1,
                                '& .MuiOutlinedInput-root': {
                                    fontSize: { xs: '12px', sm: '14px' },
                                    height: '32px'
                                }
                            }}
                        />
                        <IconButton
                            size="small"
                            onClick={() => onSaveOption(nodeId)}
                            sx={{ color: '#4caf50', padding: '2px' }}
                        >
                            <SaveIcon fontSize="small" />
                        </IconButton>
                        <IconButton
                            size="small"
                            onClick={onCancelEdit}
                            sx={{ color: '#f44336', padding: '2px' }}
                        >
                            <CancelIcon fontSize="small" />
                        </IconButton>
                    </Box>
                ) : (
                    // Display option with edit button at start
                    <Box sx={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 0.5,
                        flex: 1,
                        wordBreak: 'break-word',
                        overflow: 'hidden'
                    }}>
                        <IconButton
                            size="small"
                            onClick={() => onStartEditingOption(nodeId, optionIndex)}
                            sx={{
                                color: '#2196f3',
                                opacity: 0.7,
                                '&:hover': { opacity: 1 },
                                padding: '2px'
                            }}
                        >
                            <EditIcon fontSize="small" />
                        </IconButton>
                        <IconButton
                            size="small"
                            onClick={() => onDeleteOption(nodeId, optionIndex)}
                            sx={{
                                color: '#f44336',
                                opacity: 0.7,
                                '&:hover': { opacity: 1 },
                                padding: '2px'
                            }}
                        >
                            <DeleteIcon fontSize="small" />
                        </IconButton>
                        <Box sx={{
                            minWidth: { xs: '16px', sm: '20px' },
                            fontWeight: 'bold',
                            marginRight: { xs: '4px', sm: '8px' },
                            fontSize: { xs: '11px', sm: '14px' }
                        }}>
                            {optionIndex + 1}.
                        </Box>
                        <Box sx={{
                            flex: 1,
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: { xs: 'nowrap', sm: 'normal' }
                        }}>
                            {option}
                        </Box>
                    </Box>
                )}
            </Box>

            {/* Navigation - Middle Column */}
            <Box sx={{
                fontWeight: '500',
                fontSize: { xs: '10px', sm: '12px', md: '14px' },
                whiteSpace: { xs: 'nowrap', sm: 'normal' },
                textAlign: { xs: 'center', sm: 'left' },
                overflow: 'hidden',
                textOverflow: 'ellipsis'
            }}>
                {isEditingReferral || onGetCurrentConnection(nodeId, optionIndex) === 'Referral Text' ? (
                    // Show text field for editing referral text
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                        <TextField
                            defaultValue={optionData?.referralText || 'Refer to '}
                            variant="outlined"
                            size="small"
                            sx={{
                                flex: 1,
                                '& .MuiOutlinedInput-root': {
                                    fontSize: { xs: '10px', sm: '12px', md: '14px' },
                                    height: '28px'
                                }
                            }}
                            placeholder="Enter referral text..."
                            onBlur={(e) => {
                                onSaveReferralText(nodeId, optionIndex, e.target.value);
                            }}
                            onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                    const target = e.target as HTMLInputElement;
                                    onSaveReferralText(nodeId, optionIndex, target.value);
                                } else if (e.key === 'Escape') {
                                    // Clear referral text and switch back to dropdown
                                    const currentNode = nodes.find(n => n.id === nodeId);
                                    if (currentNode) {
                                        const currentOptionsData = currentNode.data?.optionsData || [];
                                        const newOptionsData = [...currentOptionsData];
                                        
                                        // Ensure the array is long enough
                                        while (newOptionsData.length <= optionIndex) {
                                            newOptionsData.push({});
                                        }
                                        
                                        // Clear the referral text for this option
                                        newOptionsData[optionIndex] = {
                                            ...newOptionsData[optionIndex],
                                            referralText: ''
                                        };
                                        
                                        onUpdateNode(nodeId, { optionsData: newOptionsData });
                                    }
                                    onSetEditingReferralText('', -1);
                                }
                            }}
                            autoFocus
                        />
                        <IconButton
                            size="small"
                            onClick={() => {
                                // Clear referral text and switch back to dropdown
                                const currentNode = nodes.find(n => n.id === nodeId);
                                if (currentNode) {
                                    const currentOptionsData = currentNode.data?.optionsData || [];
                                    const newOptionsData = [...currentOptionsData];
                                    
                                    // Ensure the array is long enough
                                    while (newOptionsData.length <= optionIndex) {
                                        newOptionsData.push({});
                                    }
                                    
                                    // Clear the referral text for this option
                                    newOptionsData[optionIndex] = {
                                        ...newOptionsData[optionIndex],
                                        referralText: ''
                                    };
                                    
                                    onUpdateNode(nodeId, { optionsData: newOptionsData });
                                }
                                onSetEditingReferralText('', -1);
                            }}
                            sx={{ color: '#f44336', padding: '2px' }}
                        >
                            <CancelIcon fontSize="small" />
                        </IconButton>
                    </Box>
                ) : (
                    // Show dropdown for navigation selection
                    <FormControl size="small" sx={{ minWidth: 120 }}>
                        <Select
                            value={onGetCurrentConnection(nodeId, optionIndex)}
                            onChange={(e) => onConnectionChange(nodeId, optionIndex, e.target.value)}
                            displayEmpty
                            sx={{
                                fontSize: { xs: '10px', sm: '12px', md: '14px' },
                                '& .MuiSelect-select': {
                                    paddingY: '4px',
                                    color: onGetCurrentConnection(nodeId, optionIndex).includes('Q') ? '#2196f3' :
                                           onGetCurrentConnection(nodeId, optionIndex) === 'No Connection' ? '#9e9e9e' : '#ff5722'
                                }
                            }}
                        >
                            <MenuItem value="No Connection">No Connection</MenuItem>
                            <MenuItem value="Referral Text">Referral Text</MenuItem>
                            <Divider />
                            {onGetAvailableQuestions(nodeId).map((question) => (
                                <MenuItem key={question.value} value={question.value}>
                                    {question.label}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                )}
            </Box>

            {/* Score - Right Column (Directly Editable) */}
            <Box sx={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'flex-end',
                minWidth: { xs: '50px', sm: '60px', md: '80px' }
            }}>
                <TextField
                    value={optionData?.score !== undefined ? optionData.score : '0'}
                    onChange={(e) => {
                        const value = e.target.value;
                        const currentNode = nodes.find(n => n.id === nodeId);
                        if (currentNode) {
                            const currentOptionsData = currentNode.data?.optionsData || [];
                            const newOptionsData = [...currentOptionsData];
                            
                            // Ensure the array is long enough
                            while (newOptionsData.length <= optionIndex) {
                                newOptionsData.push({});
                            }
                            
                            // Update the score for this option
                            newOptionsData[optionIndex] = {
                                ...newOptionsData[optionIndex],
                                score: value
                            };
                            
                            onUpdateNode(nodeId, { optionsData: newOptionsData });
                        }
                    }}
                    variant="outlined"
                    size="small"
                    type="number"
                    sx={{
                        width: { xs: '50px', sm: '60px', md: '80px' },
                        '& .MuiOutlinedInput-root': {
                            fontSize: { xs: '10px', sm: '12px', md: '14px' },
                            height: '28px'
                        }
                    }}
                />
            </Box>
        </Box>
    );
};

// Table View Component with editable functionality
const TableView: React.FC<{
    nodes: any[];
    edges: any[];
    onUpdateNode?: (nodeId: string, updates: any) => void;
    onDeleteNode?: (nodeId: string) => void;
    onAddNode?: (afterNodeId?: string, questionData?: any) => void;
    onUpdateEdges?: (newEdges: any[]) => void;
}> = ({ nodes, edges, onUpdateNode, onDeleteNode, onAddNode, onUpdateEdges }) => {
    const [editingNode, setEditingNode] = useState<string | null>(null);
    const [editingOption, setEditingOption] = useState<{ nodeId: string; optionIndex: number } | null>(null);
    const [editingQuestionNumber, setEditingQuestionNumber] = useState<string | null>(null);
    const [editingQuestionNumberValue, setEditingQuestionNumberValue] = useState<string>('');
    const [isSorting, setIsSorting] = useState<boolean>(false);
    const [duplicateError, setDuplicateError] = useState<string | null>(null);

    // Drag and drop sensors
    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    );

    // Handle drag end for options reordering
    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event;

        if (!over || !onUpdateNode) return;

        const activeId = active.id as string;
        const overId = over.id as string;

        // Extract nodeId and optionIndex from the IDs
        const activeMatch = activeId.match(/^option-(\w+)-(\d+)$/);
        const overMatch = overId.match(/^option-(\w+)-(\d+)$/);

        if (!activeMatch || !overMatch) return;

        const activeNodeId = activeMatch[1];
        const activeOptionIndex = parseInt(activeMatch[2]);
        const overNodeId = overMatch[1];
        const overOptionIndex = parseInt(overMatch[2]);

        // Only reorder if it's the same node
        if (activeNodeId !== overNodeId) return;

        const node = nodes.find(n => n.id === activeNodeId);
        if (!node || !node.data?.options) return;

        const options = [...node.data.options];
        const optionsData = [...(node.data.optionsData || [])];

        // Reorder the options array
        const reorderedOptions = arrayMove(options, activeOptionIndex, overOptionIndex);
        const reorderedOptionsData = arrayMove(optionsData, activeOptionIndex, overOptionIndex);

        // Update the node with reordered options
        onUpdateNode(activeNodeId, {
            options: reorderedOptions,
            optionsData: reorderedOptionsData
        });

        // Update edges to reflect new option indices
        if (onUpdateEdges) {
            const updatedEdges = edges.map(edge => {
                if (edge.source === activeNodeId) {
                    const sourceHandleMatch = edge.sourceHandle?.match(/^option-(\d+)$/);
                    if (sourceHandleMatch) {
                        const oldIndex = parseInt(sourceHandleMatch[1]);
                        let newIndex = oldIndex;

                        // Calculate new index based on reordering
                        if (oldIndex === activeOptionIndex) {
                            newIndex = overOptionIndex;
                        } else if (oldIndex > activeOptionIndex && oldIndex <= overOptionIndex) {
                            newIndex = oldIndex - 1;
                        } else if (oldIndex < activeOptionIndex && oldIndex >= overOptionIndex) {
                            newIndex = oldIndex + 1;
                        }

                        return {
                            ...edge,
                            sourceHandle: `option-${newIndex}`
                        };
                    }
                }
                return edge;
            });

            onUpdateEdges(updatedEdges);
        }
    };

    const [addingQuestion, setAddingQuestion] = useState<{ afterNodeId?: string } | null>(null);
    const [editValues, setEditValues] = useState<{ question?: string; options?: string[]; responses?: string[] }>({});
    const [editingReferralText, setEditingReferralText] = useState<{ nodeId: string; optionIndex: number } | null>(null);
    const [deleteConfirmation, setDeleteConfirmation] = useState<{
        open: boolean;
        nodeId: string;
        nodeName: string;
        incomingEdges: number;
        outgoingEdges: number;
    }>({
        open: false,
        nodeId: '',
        nodeName: '',
        incomingEdges: 0,
        outgoingEdges: 0
    });
    const [newQuestionData, setNewQuestionData] = useState<{
        question: string;
        questionType: string;
        options: string[];
        isRequired: boolean;
        navigation: { [optionIndex: number]: string };
    }>({
        question: '',
        questionType: 'multiple-choice',
        options: ['Option 1', 'Option 2'],
        isRequired: false,
        navigation: { 0: 'Referral Text', 1: 'Referral Text' }
    });

    // Helper function to normalize question number for display
    const normalizeQuestionNumberForDisplay = (questionNumber: any) => {
        const normalized = normalizeQuestionNumber(questionNumber);
        return normalized || '?';
    };


    // Force re-render when nodes or edges change to ensure dynamic updates
    useEffect(() => {
        // This effect ensures the component re-renders when data changes
        // and recalculates all question numbers and connections
        console.log('Nodes or edges changed, updating preview...');
    }, [nodes, edges]);

    // Check for duplicate question numbers using common utility
    const checkForDuplicateQuestionNumbers = (newQuestionNumber: string, excludeNodeId?: string): boolean => {
        const existingQuestionNumbers = nodes.map(node => node.data.questionNumber);
        const excludeQuestionNumber = excludeNodeId 
            ? nodes.find(node => node.id === excludeNodeId)?.data.questionNumber 
            : undefined;
            
        return checkForDuplicateQuestionNumber(newQuestionNumber, existingQuestionNumbers, excludeQuestionNumber);
    };

    // Handle question number editing
    const handleQuestionNumberEdit = (nodeId: string, currentValue: string) => {
        setEditingQuestionNumber(nodeId);
        setEditingQuestionNumberValue(currentValue);
        
        // Check if the current value is a duplicate and set error state immediately
        if (currentValue && checkForDuplicateQuestionNumbers(currentValue, nodeId)) {
            setDuplicateError(currentValue);
        } else {
            setDuplicateError(null);
        }
    };

    const handleQuestionNumberSave = (nodeId: string) => {
        if (!onUpdateNode || !editingQuestionNumberValue.trim()) {
            setEditingQuestionNumber(null);
            setEditingQuestionNumberValue('');
            return;
        }

        const trimmedValue = editingQuestionNumberValue.trim();
        
        // Check for duplicate question numbers
        if (checkForDuplicateQuestionNumbers(trimmedValue, nodeId)) {
            setDuplicateError(trimmedValue);
            toast.error(`Question number "${trimmedValue}" already exists. Please use a different number.`, {
                position: "top-right",
                autoClose: 3000,
                hideProgressBar: false,
                closeOnClick: true,
                pauseOnHover: true,
                draggable: true,
            });
            return; // Don't save if duplicate found
        }

        // Clear any previous duplicate error
        setDuplicateError(null);

        // Save the question number
        onUpdateNode(nodeId, { questionNumber: trimmedValue });
        
        // Trigger sorting animation
        setIsSorting(true);
        setTimeout(() => {
            setIsSorting(false);
        }, 1000); // Animation duration

        setEditingQuestionNumber(null);
        setEditingQuestionNumberValue('');
    };

    const handleQuestionNumberCancel = () => {
        setEditingQuestionNumber(null);
        setEditingQuestionNumberValue('');
    };

    const handleQuestionNumberKeyDown = (e: React.KeyboardEvent, nodeId: string) => {
        if (e.key === 'Enter') {
            handleQuestionNumberSave(nodeId);
        } else if (e.key === 'Escape') {
            handleQuestionNumberCancel();
        }
    };

    // Helper function to get available question numbers for navigation
    const getAvailableQuestions = (currentNodeId: string) => {
        const questionNumbers = [];
        
        // Sort nodes by questionNumber to maintain proper order
        const sortedNodes = [...nodes].sort((a, b) => {
            const parseQuestionNumber = (num: any) => {
                return parseQuestionNumberForSorting(num);
            };
            
            const aValue = parseQuestionNumber(a.data.questionNumber);
            const bValue = parseQuestionNumber(b.data.questionNumber);
            
            // Compare numeric parts first
            if (aValue.numeric !== bValue.numeric) {
                return aValue.numeric - bValue.numeric;
            }
            
            // If numeric parts are equal, compare letter parts alphabetically
            return aValue.letter.localeCompare(bValue.letter);
        });
        
        sortedNodes.forEach((node) => {
            if (node.id !== currentNodeId) { // Exclude current question
                const questionNumber = normalizeQuestionNumberForDisplay(node.data.questionNumber);
                questionNumbers.push({ 
                    value: node.id, // Use node ID as value for connections
                    label: `Move to Q${questionNumber}` // Use normalized question number as label
                });
            }
        });
        
        return questionNumbers;
    };

    // Helper function to get current connection for an option
    const getCurrentConnection = (nodeId: string, optionIndex: number) => {
        const node = nodes.find(n => n.id === nodeId);
        const optionData = node?.data?.optionsData?.[optionIndex];
        
        // Check for actual edge connections first
        const nodeEdges = edges.filter(edge => edge.source === nodeId);
        const optionHandle = `option-${optionIndex}`;
        const edge = nodeEdges.find(e => e.sourceHandle === optionHandle);
        
        if (edge) {
            const targetNode = nodes.find(n => n.id === edge.target);
            if (targetNode) {
                // Return the target node ID as the value
                return targetNode.id;
            }
        }
        
        // Only check for referral text if there's no actual connection
        if (optionData?.referralText && optionData.referralText.trim()) {
            return 'Referral Text';
        }
        
        return 'No Connection';
    };

    // Handle connection change
    const handleConnectionChange = (sourceNodeId: string, optionIndex: number, newTarget: string) => {
        if (!onUpdateEdges) {
            console.warn('⚠️ onUpdateEdges callback is not available');
            return;
        }

        // Remove any existing connection for this option
        const newEdges = edges.filter(edge => 
            !(edge.source === sourceNodeId && edge.sourceHandle === `option-${optionIndex}`)
        );

        // If not "No Connection" and not "Referral Text", create a new edge
        if (newTarget !== 'No Connection' && newTarget !== 'Referral Text') {
            const targetNode = nodes.find(n => n.id === newTarget);
            
            if (targetNode) {
                const sourceNode = nodes.find(n => n.id === sourceNodeId);
                const optionText = sourceNode?.data?.options?.[optionIndex] || 'Option';
                
                const newEdge = {
                    id: `${sourceNodeId}-${targetNode.id}-option-${optionIndex}-${Date.now()}`,
                    source: sourceNodeId,
                    target: targetNode.id,
                    sourceHandle: `option-${optionIndex}`,
                    type: 'smoothstep',
                    animated: true,
                    style: {
                        stroke: '#2196f3',
                        strokeWidth: 2,
                        strokeDasharray: '5,5',
                    },
                    data: {
                        optionText: optionText,
                        sourceHandle: `option-${optionIndex}`,
                        condition: sourceNode?.data?.questionType,
                    },
                    label: optionText,
                    labelStyle: {
                        fill: '#2196f3',
                        fontWeight: 600,
                        fontSize: '12px',
                    },
                    labelBgStyle: {
                        fill: 'white',
                        fillOpacity: 0.9,
                        rx: 4,
                        stroke: '#2196f3',
                        strokeWidth: 1,
                    },
                    labelBgPadding: [4, 8],
                    labelShowBg: true,
                };
                
                newEdges.push(newEdge);
            }
        }

        // Clear referral text when switching away from "Referral Text"
        if (newTarget !== 'Referral Text' && onUpdateNode) {
            const currentNode = nodes.find(n => n.id === sourceNodeId);
            if (currentNode) {
                const currentOptionsData = currentNode.data?.optionsData || [];
                const newOptionsData = [...currentOptionsData];

                // Ensure the array is long enough
                while (newOptionsData.length <= optionIndex) {
                    newOptionsData.push({});
                }

                // Clear the referral text for this option
                newOptionsData[optionIndex] = {
                    ...newOptionsData[optionIndex],
                    referralText: ''
                };

                onUpdateNode(sourceNodeId, { optionsData: newOptionsData });
            }
        }

        // If "Referral Text" is selected, start editing the referral text
        if (newTarget === 'Referral Text') {
            setEditingReferralText({ nodeId: sourceNodeId, optionIndex });
        }

        // Update the edges through the callback
        onUpdateEdges(newEdges);
    };

    // Handle editing functions
    const startEditingQuestion = (nodeId: string, currentQuestion: string) => {
        setEditingNode(nodeId);
        setEditValues({ question: currentQuestion });
    };

    const saveQuestion = (nodeId: string) => {
        if (editValues.question && onUpdateNode) {
            onUpdateNode(nodeId, { question: editValues.question });
        }
        cancelEdit();
    };

    const startEditingOption = (nodeId: string, optionIndex: number) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node) {
            setEditingOption({ nodeId, optionIndex });
            setEditValues({ options: [...(node.data.options || [])] });
        }
    };

    const saveOption = (nodeId: string) => {
        if (editValues.options && onUpdateNode) {
            onUpdateNode(nodeId, { options: editValues.options });
        }
        setEditingOption(null);
        setEditValues({});
    };

    const cancelEdit = () => {
        setEditingNode(null);
        setEditingOption(null);
        setAddingQuestion(null);
        setEditingReferralText(null);
        setEditValues({});
    };

    // Handle referral text editing
    const saveReferralText = (nodeId: string, optionIndex: number, referralText: string) => {
        if (onUpdateNode) {
            const currentNode = nodes.find(n => n.id === nodeId);
            if (currentNode) {
                const currentOptionsData = currentNode.data?.optionsData || [];
                const newOptionsData = [...currentOptionsData];

                // Ensure the array is long enough
                while (newOptionsData.length <= optionIndex) {
                    newOptionsData.push({});
                }

                // Update the referral text for this option
                newOptionsData[optionIndex] = {
                    ...newOptionsData[optionIndex],
                    referralText: referralText
                };

                onUpdateNode(nodeId, { optionsData: newOptionsData });
            }
        }
        setEditingReferralText(null);
    };

    const cancelReferralTextEdit = () => {
        setEditingReferralText(null);
    };

    // Delete functions

    const deleteOption = (nodeId: string, optionIndex: number) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node && node.data?.options && onUpdateNode) {
            const newOptions = node.data.options.filter((_, index: number) => index !== optionIndex);
            onUpdateNode(nodeId, { options: newOptions });
        }
    };

    // Add functions
    const addOption = (nodeId: string) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node && onUpdateNode) {
            const currentOptions = node.data?.options || [];
            const newOptions = [...currentOptions, `Option ${currentOptions.length + 1}`];
            onUpdateNode(nodeId, { options: newOptions });
        }
    };



    const saveNewQuestion = () => {
        if (onAddNode && newQuestionData.question.trim()) {
            // Create the new question node data
            const questionData = {
                question: newQuestionData.question,
                questionType: newQuestionData.questionType,
                options: newQuestionData.options,
                isRequired: newQuestionData.isRequired
            };

            onAddNode(addingQuestion?.afterNodeId, questionData);
            setAddingQuestion(null);
            setNewQuestionData({
                question: '',
                questionType: 'multiple-choice',
                options: ['Option 1', 'Option 2'],
                isRequired: false,
                navigation: { 0: 'Referral Text', 1: 'Referral Text' }
            });
        }
    };

    const cancelAddQuestion = () => {
        setAddingQuestion(null);
        setNewQuestionData({
            question: '',
            questionType: 'multiple-choice',
            options: ['Option 1', 'Option 2'],
            isRequired: false,
            navigation: { 0: 'Referral Text', 1: 'Referral Text' }
        });
    };

    // Toggle required status
    const toggleRequired = (nodeId: string, isRequired: boolean) => {
        if (onUpdateNode) {
            onUpdateNode(nodeId, { isRequired: isRequired });
        }
    };


    // Helper function to get option connections with improved logic
    const getOptionConnections = (nodeId: string) => {
        const connections: { [key: string]: { hasConnection: boolean; targetNumber?: number } } = {};

        // Find edges from this node
        const nodeEdges = edges.filter(edge => edge.source === nodeId);

        nodeEdges.forEach(edge => {
            const sourceHandle = edge.sourceHandle;
            const targetNode = nodes.find(n => n.id === edge.target);

            if (targetNode && sourceHandle) {
                let optionText = '';

                // Handle different source handle types
                if (sourceHandle === 'yes') {
                    optionText = 'Yes';
                } else if (sourceHandle === 'no') {
                    optionText = 'No';
                } else if (sourceHandle.startsWith('option-')) {
                    // Extract option index and get the actual option text
                    const optionIndex = parseInt(sourceHandle.replace('option-', ''));
                    const sourceNode = nodes.find(n => n.id === nodeId);
                    if (sourceNode && sourceNode.data.options && sourceNode.data.options[optionIndex]) {
                        optionText = sourceNode.data.options[optionIndex];
                    }
                } else if (sourceHandle === 'multi-all') {
                    optionText = 'All Selected';
                } else if (sourceHandle === 'text-output') {
                    optionText = 'Any Text';
                }

                // Calculate target question number based on node order in the array
                const targetNumber = nodes.findIndex(n => n.id === targetNode.id) + 1;

                if (optionText) {
                    connections[optionText] = {
                        hasConnection: true,
                        targetNumber: targetNumber
                    };
                }
            }
        });

        return connections;
    };

    return (
        <Box sx={{
            height: '100%',
            overflow: 'auto',
            backgroundColor: '#ffffff'
        }}>
            {/* Table Header */}
            <Box sx={{
                display: 'grid',
                gridTemplateColumns: {
                    xs: '50px 1fr',
                    sm: '60px 1fr',
                    md: '70px 1fr'
                },
                backgroundColor: '#e3f2fd',
                fontWeight: 'bold',
                fontSize: { xs: '12px', sm: '14px', md: '16px' },
                color: '#1976d2',
                borderBottom: '2px solid #1976d2',
                position: 'sticky',
                top: 0,
                zIndex: 1
            }}>
                <Box sx={{
                    padding: { xs: '4px 2px', sm: '6px 4px', md: '8px 6px' },
                    textAlign: 'center'
                }}>
                    S.No
                </Box>
                <Box sx={{
                    padding: { xs: '8px 4px', sm: '12px 8px', md: '16px' }
                }}>
                    Question
                </Box>
            </Box>

            {/* Table Rows */}
            <Box sx={{
                transition: isSorting ? 'all 0.8s ease-in-out' : 'none',
                transform: isSorting ? 'scale(1.02)' : 'scale(1)',
                opacity: isSorting ? 0.8 : 1
            }}>
            {nodes
                .sort((a, b) => {
                    // Sort by questionNumber if available, otherwise by index
                    const aNumber = a.data.questionNumber || 0;
                    const bNumber = b.data.questionNumber || 0;
                    
                    // Handle alphanumeric sorting (e.g., 1, 2, 3, 4, 5a, 5b, 6)
                    const parseQuestionNumber = (num: any): { numeric: number; letter: string } => {
                        return parseQuestionNumberForSorting(num);
                    };
                    
                    const aValue = parseQuestionNumber(aNumber);
                    const bValue = parseQuestionNumber(bNumber);
                    
                    // Compare numeric parts first
                    if (aValue.numeric !== bValue.numeric) {
                        return aValue.numeric - bValue.numeric;
                    }
                    
                    // If numeric parts are equal, compare letter parts alphabetically
                    return aValue.letter.localeCompare(bValue.letter);
                })
                .map((node, index) => {
                const optionConnections = getOptionConnections(node.id);
                const hasOptions = ['multiple-choice', 'checkbox', 'radio', 'select', 'yes-no'].includes(node.data.questionType);

                return (
                    <Box key={node.id} sx={{
                        borderBottom: '1px solid #e1e8ed',
                        backgroundColor: index % 2 === 0 ? '#ffffff' : '#f8fafe',
                        transition: 'all 0.5s ease-in-out',
                        transform: isSorting ? 'translateY(0)' : 'translateY(0)',
                        opacity: isSorting ? 0.9 : 1,
                        '&:hover': {
                            backgroundColor: isSorting ? (index % 2 === 0 ? '#ffffff' : '#f8fafe') : '#f0f8ff',
                            transform: isSorting ? 'translateY(0)' : 'translateY(-1px)',
                            boxShadow: isSorting ? 'none' : '0 2px 8px rgba(0,0,0,0.1)'
                        }
                    }}>
                        {/* Main Question Row */}
                        <Box sx={{
                            display: 'grid',
                            gridTemplateColumns: {
                                xs: '50px 1fr',
                                sm: '60px 1fr',
                                md: '70px 1fr'
                            },
                            minHeight: { xs: '40px', sm: '50px', md: '60px' }
                        }}>
                            {/* Question Number */}
                            <Box sx={{
                                padding: { xs: '4px 2px', sm: '6px 4px', md: '8px 6px' },
                                fontWeight: 'bold',
                                fontSize: { xs: '12px', sm: '14px', md: '16px' },
                                color: '#2c3e50',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                borderRight: '1px solid #e1e8ed',
                                position: 'relative',
                                cursor: 'pointer',
                                transition: 'all 0.2s ease-in-out',
                                '&:hover': {
                                    backgroundColor: '#f5f5f5',
                                    borderRadius: '4px',
                                    transform: 'scale(1.02)',
                                    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                                }
                            }}
                            onClick={() => handleQuestionNumberEdit(node.id, normalizeQuestionNumberForDisplay(node.data.questionNumber) || (index + 1).toString())}
                            >
                                {editingQuestionNumber === node.id ? (
                                    <TextField
                                        value={editingQuestionNumberValue}
                                        onChange={(e) => {
                                            setEditingQuestionNumberValue(e.target.value);
                                            // Clear duplicate error when user starts typing
                                            if (duplicateError) {
                                                setDuplicateError(null);
                                            }
                                        }}
                                        onBlur={() => handleQuestionNumberSave(node.id)}
                                        onKeyDown={(e) => handleQuestionNumberKeyDown(e, node.id)}
                                        variant="outlined"
                                        size="small"
                                        autoFocus
                                        error={duplicateError === editingQuestionNumberValue.trim() || checkForDuplicateQuestionNumbers(editingQuestionNumberValue, node.id)}
                                        helperText={(duplicateError === editingQuestionNumberValue.trim() || checkForDuplicateQuestionNumbers(editingQuestionNumberValue, node.id)) ? 'Duplicate question number' : ''}
                                        sx={{
                                            '& .MuiOutlinedInput-root': {
                                                fontSize: { xs: '12px', sm: '14px', md: '16px' },
                                                fontWeight: 'bold',
                                                height: { xs: '24px', sm: '28px', md: '32px' },
                                                '& input': {
                                                    padding: { xs: '4px 8px', sm: '6px 8px', md: '8px 8px' },
                                                    textAlign: 'center'
                                                }
                                            },
                                            '& .MuiFormHelperText-root': {
                                                fontSize: '10px',
                                                margin: '2px 0 0 0',
                                                textAlign: 'center'
                                            }
                                        }}
                                    />
                                ) : (
                                    <Box sx={{
                                        transition: 'all 0.3s ease-in-out',
                                        transform: 'translateY(0)',
                                        opacity: 1
                            }}>
                                {normalizeQuestionNumberForDisplay(node.data.questionNumber) || (index + 1)}
                                    </Box>
                                )}
                            </Box>

                            {/* Question Column */}
                            <Box sx={{ padding: { xs: '8px 4px', sm: '12px 8px', md: '16px' } }}>
                                {editingNode === node.id ? (
                                    // Editable question
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                        <TextField
                                            value={editValues.question || ''}
                                            onChange={(e) => setEditValues({ ...editValues, question: e.target.value })}
                                            variant="outlined"
                                            size="small"
                                            fullWidth
                                            sx={{
                                                '& .MuiOutlinedInput-root': {
                                                    fontSize: { xs: '14px', sm: '16px' },
                                                    fontWeight: '600'
                                                }
                                            }}
                                        />
                                        <IconButton
                                            size="small"
                                            onClick={() => saveQuestion(node.id)}
                                            sx={{ color: '#4caf50', padding: '4px' }}
                                        >
                                            <SaveIcon fontSize="small" />
                                        </IconButton>
                                        <IconButton
                                            size="small"
                                            onClick={cancelEdit}
                                            sx={{ color: '#f44336', padding: '4px' }}
                                        >
                                            <CancelIcon fontSize="small" />
                                        </IconButton>
                                    </Box>
                                ) : (
                                    // Display question with controls
                                    <Box>
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, marginBottom: 1 }}>
                                            {editingNode === node.id ? (
                                                // Editable question
                                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flex: 1 }}>
                                                    <TextField
                                                        value={editValues.question || ''}
                                                        onChange={(e) => setEditValues({ ...editValues, question: e.target.value })}
                                                        variant="outlined"
                                                        size="small"
                                                        sx={{
                                                            flex: 1,
                                                            '& .MuiOutlinedInput-root': {
                                                                fontSize: { xs: '14px', sm: '16px' },
                                                                fontWeight: '600',
                                                                height: '40px'
                                                            }
                                                        }}
                                                    />
                                                    <IconButton
                                                        size="small"
                                                        onClick={() => saveQuestion(node.id)}
                                                        sx={{ color: '#4caf50', padding: '4px' }}
                                                    >
                                                        <SaveIcon fontSize="small" />
                                                    </IconButton>
                                                    <IconButton
                                                        size="small"
                                                        onClick={cancelEdit}
                                                        sx={{ color: '#f44336', padding: '4px' }}
                                                    >
                                                        <CancelIcon fontSize="small" />
                                                    </IconButton>
                                                </Box>
                                            ) : (
                                                // Display question with edit button
                                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flex: 1 }}>
                                                    <Typography sx={{
                                                        fontWeight: '600',
                                                        fontSize: { xs: '14px', sm: '16px' },
                                                        color: '#2c3e50',
                                                        lineHeight: 1.4,
                                                        wordBreak: 'break-word',
                                                        flex: 1
                                                    }}>
                                                        {node.data.question || 'Untitled Question'}
                                                    </Typography>

                                                    {/* Edit Button */}
                                                    <IconButton
                                                        size="small"
                                                        onClick={() => startEditingQuestion(node.id, node.data.question || '')}
                                                        sx={{
                                                            color: '#2196f3',
                                                            opacity: 0.7,
                                                            '&:hover': { opacity: 1 },
                                                            padding: '4px'
                                                        }}
                                                    >
                                                        <EditIcon fontSize="small" />
                                                    </IconButton>

                                                    {/* Delete Button */}
                                                    <IconButton
                                                        size="small"
                                                        onClick={() => {
                                                            // Check if this node has connections
                                                            const incomingEdges = edges.filter(edge => edge.target === node.id);
                                                            const outgoingEdges = edges.filter(edge => edge.source === node.id);

                                                            // Open delete confirmation dialog
                                                            setDeleteConfirmation({
                                                                open: true,
                                                                nodeId: node.id,
                                                                nodeName: node.data.question || 'Untitled Question',
                                                                incomingEdges: incomingEdges.length,
                                                                outgoingEdges: outgoingEdges.length
                                                            });
                                                        }}
                                                        sx={{
                                                            color: '#f44336',
                                                            opacity: 0.7,
                                                            '&:hover': { opacity: 1 },
                                                            padding: '4px'
                                                        }}
                                                    >
                                                        <DeleteIcon fontSize="small" />
                                                    </IconButton>
                                                </Box>
                                            )}
                                        </Box>

                                        {/* Required Checkbox */}
                                        {/* <FormControlLabel
                                            control={
                                                <Checkbox
                                                    checked={node.data?.isRequired || false}
                                                    onChange={(e) => toggleRequired(node.id, e.target.checked)}
                                                    size="small"
                                                    sx={{ color: '#2196f3' }}
                                                />
                                            }
                                            label="Required Question"
                                            sx={{
                                                margin: 0,
                                                '& .MuiFormControlLabel-label': {
                                                    fontSize: { xs: '11px', sm: '12px' },
                                                    color: '#666'
                                                }
                                            }}
                                        /> */}
                                    </Box>
                                )}

                                {/* Show options with S.No and responses inline */}
                                {hasOptions && (
                                    <Box sx={{ marginTop: '12px' }}>
                                        {node.data.questionType === 'yes-no' ? (
                                            // For yes-no questions, show Yes and No options with responses and scores
                                            ['Yes', 'No'].map((option: string, optIndex: number) => {
                                                const optionData = node.data.optionsData?.[optIndex];

                                                return (
                                                    <Box key={optIndex} sx={{
                                                        display: 'grid',
                                                        gridTemplateColumns: {
                                                            xs: '1fr auto auto',
                                                            sm: '2fr 1fr auto',
                                                            md: '2fr 1fr 80px'
                                                        },
                                                        alignItems: 'center',
                                                        padding: '4px 0',
                                                        fontSize: { xs: '12px', sm: '14px' },
                                                        color: '#333',
                                                        gap: { xs: 1, sm: 2 }
                                                    }}>
                                                        {/* Option Text - Left Side */}
                                                        <Box sx={{
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: 0.5,
                                                            flex: 1,
                                                            wordBreak: 'break-word',
                                                            overflow: 'hidden'
                                                        }}>
                                                            <Box sx={{
                                                                minWidth: { xs: '16px', sm: '20px' },
                                                                fontWeight: 'bold',
                                                                marginRight: { xs: '4px', sm: '8px' },
                                                                fontSize: { xs: '11px', sm: '14px' }
                                                            }}>
                                                                {optIndex + 1}.
                                                            </Box>
                                                            <Box sx={{
                                                                flex: 1,
                                                                overflow: 'hidden',
                                                                textOverflow: 'ellipsis',
                                                                whiteSpace: { xs: 'nowrap', sm: 'normal' }
                                                            }}>
                                                                {option}
                                                            </Box>
                                                        </Box>

                                                        {/* Navigation - Middle Column */}
                                                        <Box sx={{
                                                            fontWeight: '500',
                                                            fontSize: { xs: '10px', sm: '12px', md: '14px' },
                                                            whiteSpace: { xs: 'nowrap', sm: 'normal' },
                                                            textAlign: { xs: 'center', sm: 'left' },
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis'
                                                        }}>
                                                            {(editingReferralText?.nodeId === node.id && editingReferralText?.optionIndex === optIndex) || getCurrentConnection(node.id, optIndex) === 'Referral Text' ? (
                                                                // Show text field for editing referral text
                                                                <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                                                    <TextField
                                                                        defaultValue={node.data?.optionsData?.[optIndex]?.referralText || 'Refer to '}
                                                                        variant="outlined"
                                                                        size="small"
                                                                        sx={{
                                                                            flex: 1,
                                                                            '& .MuiOutlinedInput-root': {
                                                                                fontSize: { xs: '10px', sm: '12px', md: '14px' },
                                                                                height: '28px'
                                                                            }
                                                                        }}
                                                                        placeholder="Enter referral text..."
                                                                        onBlur={(e) => {
                                                                            // Auto-save on blur
                                                                            saveReferralText(node.id, optIndex, e.target.value);
                                                                        }}
                                                                        onKeyDown={(e) => {
                                                                            if (e.key === 'Enter') {
                                                                                const target = e.target as HTMLInputElement;
                                                                                saveReferralText(node.id, optIndex, target.value);
                                                                            } else if (e.key === 'Escape') {
                                                                                // Clear referral text and switch back to dropdown
                                                                                if (onUpdateNode) {
                                                                                    const currentNode = nodes.find(n => n.id === node.id);
                                                                                    if (currentNode) {
                                                                                        const currentOptionsData = currentNode.data?.optionsData || [];
                                                                                        const newOptionsData = [...currentOptionsData];
                                                                                        
                                                                                        // Ensure the array is long enough
                                                                                        while (newOptionsData.length <= optIndex) {
                                                                                            newOptionsData.push({});
                                                                                        }
                                                                                        
                                                                                        // Clear the referral text for this option
                                                                                        newOptionsData[optIndex] = {
                                                                                            ...newOptionsData[optIndex],
                                                                                            referralText: ''
                                                                                        };
                                                                                        
                                                                                        onUpdateNode(node.id, { optionsData: newOptionsData });
                                                                                    }
                                                                                }
                                                                                setEditingReferralText(null);
                                                                            }
                                                                        }}
                                                                        autoFocus
                                                                    />
                                                                    <IconButton
                                                                        size="small"
                                                                        onClick={() => {
                                                                            // Clear referral text and switch back to dropdown
                                                                            if (onUpdateNode) {
                                                                                const currentNode = nodes.find(n => n.id === node.id);
                                                                                if (currentNode) {
                                                                                    const currentOptionsData = currentNode.data?.optionsData || [];
                                                                                    const newOptionsData = [...currentOptionsData];
                                                                                    
                                                                                    // Ensure the array is long enough
                                                                                    while (newOptionsData.length <= optIndex) {
                                                                                        newOptionsData.push({});
                                                                                    }
                                                                                    
                                                                                    // Clear the referral text for this option
                                                                                    newOptionsData[optIndex] = {
                                                                                        ...newOptionsData[optIndex],
                                                                                        referralText: ''
                                                                                    };
                                                                                    
                                                                                    onUpdateNode(node.id, { optionsData: newOptionsData });
                                                                                }
                                                                            }
                                                                            setEditingReferralText(null);
                                                                        }}
                                                                        sx={{ color: '#f44336', padding: '2px' }}
                                                                    >
                                                                        <CancelIcon fontSize="small" />
                                                                    </IconButton>
                                                                </Box>
                                                            ) : (
                                                                // Show dropdown for navigation selection
                                                                <FormControl size="small" sx={{ minWidth: 120 }}>
                                                                    <Select
                                                                        value={getCurrentConnection(node.id, optIndex)}
                                                                        onChange={(e) => handleConnectionChange(node.id, optIndex, e.target.value)}
                                                                        displayEmpty
                                                                        sx={{
                                                                            fontSize: { xs: '10px', sm: '12px', md: '14px' },
                                                                            '& .MuiSelect-select': {
                                                                                paddingY: '4px',
                                                                                color: getCurrentConnection(node.id, optIndex).includes('Q') ? '#2196f3' :
                                                                                       getCurrentConnection(node.id, optIndex) === 'No Connection' ? '#9e9e9e' : '#ff5722'
                                                                            }
                                                                        }}
                                                                    >
                                                                        <MenuItem value="No Connection">No Connection</MenuItem>
                                                                        <MenuItem value="Referral Text">Referral Text</MenuItem>
                                                                        <Divider />
                                                                        {getAvailableQuestions(node.id).map((question) => (
                                                                            <MenuItem key={question.value} value={question.value}>
                                                                                {question.label}
                                                                            </MenuItem>
                                                                        ))}
                                                                    </Select>
                                                                </FormControl>
                                                            )}
                                                        </Box>

                                                        {/* Score - Right Column (Directly Editable) */}
                                                        <Box sx={{
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'flex-end',
                                                            minWidth: { xs: '50px', sm: '60px', md: '80px' }
                                                        }}>
                                                            <TextField
                                                                value={optionData?.score !== undefined ? optionData.score : '0'}
                                                                onChange={(e) => {
                                                                    const value = e.target.value;
                                                                    const currentNode = nodes.find(n => n.id === node.id);
                                                                    if (currentNode && onUpdateNode) {
                                                                        const currentOptionsData = currentNode.data?.optionsData || [];
                                                                        const newOptionsData = [...currentOptionsData];

                                                                        // Ensure the array is long enough
                                                                        while (newOptionsData.length <= optIndex) {
                                                                            newOptionsData.push({});
                                                                        }

                                                                        // Update the score for this option
                                                                        newOptionsData[optIndex] = {
                                                                            ...newOptionsData[optIndex],
                                                                            score: value
                                                                        };

                                                                        onUpdateNode(currentNode.id, { optionsData: newOptionsData });
                                                                    }
                                                                }}
                                                                variant="outlined"
                                                                size="small"
                                                                inputProps={{
                                                                    style: {
                                                                        textAlign: 'center',
                                                                        MozAppearance: 'textfield' // Firefox
                                                                    },
                                                                    pattern: "[0-9]*\\.?[0-9]*"
                                                                }}
                                                                sx={{
                                                                    width: { xs: '50px', sm: '60px' },
                                                                    '& .MuiOutlinedInput-root': {
                                                                        fontSize: { xs: '11px', sm: '12px' },
                                                                        height: '28px',
                                                                        backgroundColor: '#f0f9f0',
                                                                        '&:hover': {
                                                                            backgroundColor: '#e8f5e8'
                                                                        },
                                                                        '&.Mui-focused': {
                                                                            backgroundColor: '#ffffff'
                                                                        }
                                                                    },
                                                                    '& input[type=number]': {
                                                                        MozAppearance: 'textfield' // Firefox
                                                                    },
                                                                    '& input[type=number]::-webkit-outer-spin-button': {
                                                                        WebkitAppearance: 'none',
                                                                        margin: 0
                                                                    },
                                                                    '& input[type=number]::-webkit-inner-spin-button': {
                                                                        WebkitAppearance: 'none',
                                                                        margin: 0
                                                                    }
                                                                }}
                                                            />
                                                        </Box>
                                                    </Box>
                                                );
                                            })
                                        ) : (
                                            // For other question types with options and responses - Drag and Drop
                                            <DndContext
                                                sensors={sensors}
                                                collisionDetection={closestCenter}
                                                onDragEnd={handleDragEnd}
                                            >
                                                <SortableContext
                                                    items={node.data.options?.map((_: any, index: number) => `option-${node.id}-${index}`) || []}
                                                    strategy={verticalListSortingStrategy}
                                                >
                                                    {node.data.options?.map((option: string, optIndex: number) => {
                                                        const optionData = node.data.optionsData?.[optIndex];
                                                        
                                                        return (
                                                            <SortableOption
                                                                key={`option-${node.id}-${optIndex}`}
                                                                id={`option-${node.id}-${optIndex}`}
                                                                option={option}
                                                                optionIndex={optIndex}
                                                                nodeId={node.id}
                                                                optionData={optionData}
                                                                isYesNo={false}
                                                                editingOption={editingOption}
                                                                editingReferralText={editingReferralText}
                                                                editValues={editValues}
                                                                onStartEditingOption={startEditingOption}
                                                                onSaveOption={saveOption}
                                                                onCancelEdit={cancelEdit}
                                                                onDeleteOption={deleteOption}
                                                                onSaveReferralText={saveReferralText}
                                                                onSetEditingReferralText={(nodeId: string, optionIndex: number) => 
                                                                    setEditingReferralText({ nodeId, optionIndex })
                                                                }
                                                                onUpdateNode={onUpdateNode || (() => {})}
                                                                onConnectionChange={handleConnectionChange}
                                                                onGetCurrentConnection={getCurrentConnection}
                                                                onGetAvailableQuestions={getAvailableQuestions}
                                                                nodes={nodes}
                                                            />
                                                        );
                                                    })}
                                                </SortableContext>
                                            </DndContext>
                                        )}

                                        {/* Add Option Button */}
                                        <Box sx={{ marginTop: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                                            <IconButton
                                                size="small"
                                                onClick={() => addOption(node.id)}
                                                sx={{
                                                    color: '#63b5f7',
                                                    backgroundColor: '#f0f8ff',
                                                    '&:hover': { backgroundColor: '#e6f3ff' },
                                                    padding: '4px'
                                                }}
                                            >
                                                <AddIcon fontSize="small" />
                                            </IconButton>
                                            <Typography sx={{
                                                fontSize: { xs: '11px', sm: '12px' },
                                                color: '#63b5f7',
                                                fontWeight: '500'
                                            }}>
                                                Add Option
                                            </Typography>
                                        </Box>

                                    </Box>
                                )}
                                
                                {/* Show Text Input for questions without options */}
                                {!hasOptions && (
                                    <Box sx={{
                                        marginTop: { xs: '8px', sm: '12px' },
                                        padding: { xs: '6px 10px', sm: '8px 14px' },
                                        backgroundColor: '#f8f9fa',
                                        borderRadius: '8px',
                                        fontSize: { xs: '12px', sm: '14px' },
                                        fontWeight: '500',
                                        color: '#6c757d',
                                        border: '1px solid #dee2e6',
                                        display: 'inline-block'
                                    }}>
                                        Text Input
                                    </Box>
                                )}
                            </Box>
                        </Box>



                        {/* Inline Question Creation Form */}
                        {addingQuestion?.afterNodeId === node.id && (
                            <Box sx={{
                                borderBottom: '1px solid #e1e8ed',
                                backgroundColor: '#f8fafe',
                                padding: 2,
                                margin: '8px 0'
                            }}>
                                <Box sx={{
                                    display: 'grid',
                                    gridTemplateColumns: { xs: '60px 1fr', sm: '70px 1fr' },
                                    minHeight: { xs: '50px', sm: '60px' }
                                }}>
                                    {/* Question Number */}
                                    <Box sx={{
                                        padding: { xs: '12px 8px', sm: '16px' },
                                        fontWeight: 'bold',
                                        fontSize: { xs: '16px', sm: '18px' },
                                        color: '#1976d2',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        borderRight: '1px solid #e1e8ed'
                                    }}>
                                        {nodes.findIndex(n => n.id === node.id) + 2}
                                    </Box>

                                    {/* Question Form */}
                                    <Box sx={{ padding: { xs: '12px 8px', sm: '16px' } }}>
                                        <Box sx={{ marginBottom: 2 }}>
                                            <TextField
                                                value={newQuestionData.question}
                                                onChange={(e) => setNewQuestionData({ ...newQuestionData, question: e.target.value })}
                                                placeholder="Enter your question..."
                                                variant="outlined"
                                                size="small"
                                                fullWidth
                                                sx={{
                                                    '& .MuiOutlinedInput-root': {
                                                        fontSize: { xs: '14px', sm: '16px' },
                                                        fontWeight: '600'
                                                    }
                                                }}
                                            />
                                        </Box>

                                        {/* Required Checkbox */}
                                        <FormControlLabel
                                            control={
                                                <Checkbox
                                                    checked={newQuestionData.isRequired}
                                                    onChange={(e) => setNewQuestionData({ ...newQuestionData, isRequired: e.target.checked })}
                                                    size="small"
                                                    sx={{ color: '#2196f3' }}
                                                />
                                            }
                                            label="Required Question"
                                            sx={{
                                                margin: 0,
                                                marginBottom: 2,
                                                '& .MuiFormControlLabel-label': {
                                                    fontSize: { xs: '11px', sm: '12px' },
                                                    color: '#666'
                                                }
                                            }}
                                        />

                                        {/* Options with Navigation */}
                                        <Typography sx={{ fontSize: '12px', color: '#666', marginBottom: 1 }}>
                                            Configure options and their navigation paths:
                                        </Typography>
                                        <Box sx={{ marginBottom: 2 }}>
                                            {newQuestionData.options.map((option, optIndex) => (
                                                <Box key={optIndex} sx={{ marginBottom: 2, padding: 1, border: '1px solid #e0e0e0', borderRadius: '8px' }}>
                                                    {/* Option Text */}
                                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, marginBottom: 1 }}>
                                                        <Typography sx={{ minWidth: '20px', fontWeight: 'bold' }}>
                                                            {optIndex + 1}.
                                                        </Typography>
                                                        <TextField
                                                            value={option}
                                                            onChange={(e) => {
                                                                const newOptions = [...newQuestionData.options];
                                                                newOptions[optIndex] = e.target.value;
                                                                setNewQuestionData({ ...newQuestionData, options: newOptions });
                                                            }}
                                                            variant="outlined"
                                                            size="small"
                                                            sx={{ flex: 1 }}
                                                            placeholder="Enter option text"
                                                        />
                                                        <IconButton
                                                            size="small"
                                                            onClick={() => {
                                                                const newOptions = newQuestionData.options.filter((_, i) => i !== optIndex);
                                                                const newNavigation = { ...newQuestionData.navigation };
                                                                delete newNavigation[optIndex];
                                                                // Reindex navigation
                                                                const reindexedNavigation: { [key: number]: string } = {};
                                                                Object.keys(newNavigation).forEach((key, index) => {
                                                                    const keyNum = parseInt(key);
                                                                    if (keyNum > optIndex) {
                                                                        reindexedNavigation[keyNum - 1] = newNavigation[keyNum];
                                                                    } else if (keyNum < optIndex) {
                                                                        reindexedNavigation[keyNum] = newNavigation[keyNum];
                                                                    }
                                                                });
                                                                setNewQuestionData({
                                                                    ...newQuestionData,
                                                                    options: newOptions,
                                                                    navigation: reindexedNavigation
                                                                });
                                                            }}
                                                            sx={{ color: '#f44336' }}
                                                        >
                                                            <DeleteIcon fontSize="small" />
                                                        </IconButton>
                                                    </Box>

                                                    {/* Navigation Selection */}
                                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, marginLeft: '24px' }}>
                                                        <Typography sx={{ fontSize: '12px', color: '#666', minWidth: '60px' }}>
                                                            Navigate to:
                                                        </Typography>
                                                        <TextField
                                                            value={newQuestionData.navigation[optIndex] || 'Referral Text'}
                                                            onChange={(e) => {
                                                                const newNavigation = { ...newQuestionData.navigation };
                                                                newNavigation[optIndex] = e.target.value;
                                                                setNewQuestionData({ ...newQuestionData, navigation: newNavigation });
                                                            }}
                                                            variant="outlined"
                                                            size="small"
                                                            sx={{
                                                                flex: 1,
                                                                '& .MuiOutlinedInput-root': {
                                                                    fontSize: '12px',
                                                                    height: '32px'
                                                                }
                                                            }}
                                                            placeholder="e.g., Move to Q3, Referral Text"
                                                        />
                                                    </Box>
                                                </Box>
                                            ))}

                                            {/* Add Option Button */}
                                            <Button
                                                size="small"
                                                startIcon={<AddIcon />}
                                                onClick={() => {
                                                    const newOptions = [...newQuestionData.options, `Option ${newQuestionData.options.length + 1}`];
                                                    const newNavigation = { ...newQuestionData.navigation };
                                                    newNavigation[newOptions.length - 1] = 'Referral Text';
                                                    setNewQuestionData({ ...newQuestionData, options: newOptions, navigation: newNavigation });
                                                }}
                                                sx={{ color: '#63b5f7', fontSize: '12px' }}
                                            >
                                                Add Option
                                            </Button>
                                        </Box>

                                        {/* Action Buttons */}
                                        <Box sx={{ display: 'flex', gap: 1 }}>
                                            <Button
                                                variant="contained"
                                                size="small"
                                                onClick={saveNewQuestion}
                                                disabled={!newQuestionData.question.trim()}
                                                sx={{ backgroundColor: '#4caf50', '&:hover': { backgroundColor: '#45a049' } }}
                                            >
                                                Save Question
                                            </Button>
                                            <Button
                                                variant="outlined"
                                                size="small"
                                                onClick={cancelAddQuestion}
                                                sx={{ color: '#f44336', borderColor: '#f44336' }}
                                            >
                                                Cancel
                                            </Button>
                                        </Box>
                                    </Box>
                                </Box>
                            </Box>
                        )}
                    </Box>
                );
            })}
            </Box>

            {/* Delete Confirmation Dialog */}
            <Dialog
                open={deleteConfirmation.open}
                onClose={() => setDeleteConfirmation(prev => ({ ...prev, open: false }))}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle sx={{ fontWeight: 600, color: '#2c3e50' }}>
                    Delete Question
                </DialogTitle>
                <DialogContent>
                    <Typography sx={{ mb: 2 }}>
                        Are you sure you want to delete the question:
                    </Typography>
                    <Typography sx={{ fontWeight: 600, color: '#2c3e50', mb: 2 }}>
                        &ldquo;{deleteConfirmation.nodeName}&rdquo;
                    </Typography>
                    {deleteConfirmation.incomingEdges > 0 && deleteConfirmation.outgoingEdges > 0 && (
                        <Typography sx={{ color: '#4caf50', fontSize: '14px' }}>
                            🔗 This will automatically reconnect {deleteConfirmation.incomingEdges} incoming connection(s) to {deleteConfirmation.outgoingEdges} outgoing connection(s).
                        </Typography>
                    )}
                    {(deleteConfirmation.incomingEdges > 0 || deleteConfirmation.outgoingEdges > 0) &&
                     !(deleteConfirmation.incomingEdges > 0 && deleteConfirmation.outgoingEdges > 0) && (
                        <Typography sx={{ color: '#ff9800', fontSize: '14px' }}>
                            ⚠️ This question has connections that will be removed.
                        </Typography>
                    )}
                </DialogContent>
                <DialogActions sx={{ p: 2 }}>
                    <Button
                        onClick={() => setDeleteConfirmation(prev => ({ ...prev, open: false }))}
                        sx={{
                            color: '#666',
                            textTransform: 'none',
                            fontWeight: 500
                        }}
                    >
                        Cancel
                    </Button>
                    <Button
                        onClick={() => {
                            if (onDeleteNode) {
                                console.log('🗑️ Live Preview: Deleting node with smart reconnection:', deleteConfirmation.nodeId);
                                console.log('📊 Current nodes before deletion:', nodes.map(n => n.id));
                                console.log('🔗 Current edges before deletion:', edges.map(e => `${e.source} → ${e.target}`));
                                console.log('📥 Incoming edges:', deleteConfirmation.incomingEdges);
                                console.log('📤 Outgoing edges:', deleteConfirmation.outgoingEdges);
                                onDeleteNode(deleteConfirmation.nodeId);
                            }
                            setDeleteConfirmation(prev => ({ ...prev, open: false }));
                        }}
                        variant="contained"
                        color="error"
                        sx={{
                            textTransform: 'none',
                            fontWeight: 600
                        }}
                    >
                        Delete
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
};

const FlowPreviewDrawer: React.FC<FlowPreviewDrawerProps> = ({
    nodes,
    edges,
    isOpen,
    onToggle,
    onUpdateNode,
    onDeleteNode,
    onAddNode,
    onUpdateEdges,
    isSplitScreen = false,
    onSplitScreenToggle,
    showStartDialog = false // Default to false
}) => {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));
    const isTablet = useMediaQuery(theme.breakpoints.down('lg'));

    // Responsive drawer width - default to 40% of screen
    const getDrawerWidth = () => {
        if (isMobile) return Math.min(window.innerWidth * 0.9, 350);
        if (isTablet) return Math.min(window.innerWidth * 0.4, 450);
        return window.innerWidth * 0.4; // Always 40% of screen width for consistency
    };

    const [drawerWidth, setDrawerWidth] = useState(getDrawerWidth());
    const [isResizing, setIsResizing] = useState(false);
    const resizeRef = useRef<HTMLDivElement>(null);

    // Update drawer width on screen size change
    useEffect(() => {
        const handleResize = () => {
            if (!isResizing) {
                setDrawerWidth(getDrawerWidth());
            }
        };

        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [isMobile, isTablet, isResizing]);

    // Update drawer width when component mounts to ensure 40% width
    useEffect(() => {
        setDrawerWidth(getDrawerWidth());
    }, []);

    // Reset drawer width to 40% whenever drawer is opened
    useEffect(() => {
        if (isOpen && !isSplitScreen) {
            setDrawerWidth(getDrawerWidth());
        }
    }, [isOpen, isSplitScreen]);

    // Handle drag resize for mouse
    const handleMouseDown = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsResizing(true);

        const startX = e.clientX;
        const startWidth = drawerWidth;

        const handleMouseMove = (e: MouseEvent) => {
            e.preventDefault();
            const deltaX = startX - e.clientX;
            const newWidth = Math.max(250, Math.min(window.innerWidth * 0.8, startWidth + deltaX));
            setDrawerWidth(newWidth);

            // Auto-hide if width becomes less than 20% of screen width
            const screenWidth = window.innerWidth;
            const twentyPercentWidth = screenWidth * 0.2;
            if (newWidth <= twentyPercentWidth) {
                // Delay the hide to avoid immediate hiding during drag
                setTimeout(() => {
                    if (drawerWidth <= twentyPercentWidth) {
                        onToggle(); // Hide the drawer
                    }
                }, 100);
            }
        };

        const handleMouseUp = (e: MouseEvent) => {
            e.preventDefault();
            setIsResizing(false);
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = 'default';
            document.body.style.userSelect = 'auto';

            // Final check for auto-hide after drag ends
            const screenWidth = window.innerWidth;
            const twentyPercentWidth = screenWidth * 0.2;
            if (drawerWidth <= twentyPercentWidth) {
                onToggle(); // Hide the drawer
            }
        };

        // Set cursor and disable text selection during drag
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    }, [drawerWidth, onToggle]);

    // Handle drag resize for touch
    const handleTouchStart = useCallback((e: React.TouchEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsResizing(true);

        const startX = e.touches[0].clientX;
        const startWidth = drawerWidth;

        const handleTouchMove = (e: TouchEvent) => {
            e.preventDefault();
            const deltaX = startX - e.touches[0].clientX;
            const newWidth = Math.max(250, Math.min(window.innerWidth * 0.8, startWidth + deltaX));
            setDrawerWidth(newWidth);

            // Auto-hide if width becomes less than 20% of screen width
            const screenWidth = window.innerWidth;
            const twentyPercentWidth = screenWidth * 0.2;
            if (newWidth <= twentyPercentWidth) {
                // Delay the hide to avoid immediate hiding during drag
                setTimeout(() => {
                    if (drawerWidth <= twentyPercentWidth) {
                        onToggle(); // Hide the drawer
                    }
                }, 100);
            }
        };

        const handleTouchEnd = (e: TouchEvent) => {
            e.preventDefault();
            setIsResizing(false);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            document.body.style.userSelect = 'auto';

            // Final check for auto-hide after drag ends
            const screenWidth = window.innerWidth;
            const twentyPercentWidth = screenWidth * 0.2;
            if (drawerWidth <= twentyPercentWidth) {
                onToggle(); // Hide the drawer
            }
        };

        // Disable text selection during drag
        document.body.style.userSelect = 'none';

        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd);
    }, [drawerWidth, onToggle]);

    // Split screen mode - render as fixed positioned element
    if (isSplitScreen && isOpen) {
        return (
            <Box sx={{
                position: 'fixed',
                right: 0,
                top: '70px',
                width: '40%', // Changed from 50% to 40% to match default drawer width
                height: 'calc(100vh - 70px)',
                backgroundColor: '#ffffff',
                borderLeft: '1px solid #e0e0e0',
                zIndex: 1000,
                overflow: 'hidden'
            }}>
                {/* Header */}
                <Box sx={{
                    padding: { xs: '8px 12px', sm: '12px 16px' },
                    borderBottom: '1px solid #e0e0e0',
                    backgroundColor: '#f8f9fa',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                }}>
                    <Typography variant="h6" sx={{
                        fontSize: { xs: '16px', sm: '18px' },
                        fontWeight: 'bold',
                        color: '#1976d2'
                    }}>
                        Live Preview
                    </Typography>
                </Box>

                {/* Content */}
                <Box sx={{
                    height: 'calc(100% - 60px)',
                    overflow: 'auto',
                    padding: { xs: '8px', sm: '12px' }
                }}>
                    <TableView
                        nodes={nodes}
                        edges={edges}
                        onUpdateNode={onUpdateNode}
                        onDeleteNode={onDeleteNode}
                        onAddNode={onAddNode}
                        onUpdateEdges={onUpdateEdges}
                    />
                </Box>
            </Box>
        );
    }

    // Hide drawer completely when StartDialog is showing
    if (showStartDialog) {
        return null;
    }

    return (
        <>
            {/* Toggle Button - Only show when not in split screen mode */}
            {!isSplitScreen && (
                <Box sx={{
                    position: 'fixed',
                    right: isOpen ? drawerWidth : 0,
                    top: 'calc(70px + 50vh - 30px)', // Position below header (70px) + center of remaining space
                    zIndex: 1300,
                    transition: isResizing ? 'none' : 'right 0.3s ease'
                }}>
                    <Tooltip title={isOpen ? "Hide Preview" : "Show Preview"} placement="left">
                        <IconButton
                            onClick={onToggle}
                            sx={{
                                backgroundColor: '#2196f3',
                                color: 'white',
                                borderRadius: '8px 0 0 8px',
                                width: '40px',
                                height: '60px',
                                '&:hover': {
                                    backgroundColor: '#1976d2'
                                },
                                boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                            }}
                        >
                            {isOpen ? <ChevronRightIcon /> : <VisibilityIcon />}
                        </IconButton>
                    </Tooltip>
                </Box>
            )}

            {/* Drawer */}
            <Drawer
                anchor="right"
                open={isOpen}
                variant="persistent"
                sx={{
                    width: drawerWidth,
                    flexShrink: 0,
                    '& .MuiDrawer-paper': {
                        width: drawerWidth,
                        boxSizing: 'border-box',
                        backgroundColor: '#ffffff',
                        borderLeft: '1px solid #e0e0e0',
                        zIndex: 1200,
                        transition: isResizing ? 'none' : 'width 0.3s ease',
                        top: '70px', // Start below header
                        height: 'calc(100vh - 70px)' // Adjust height to account for header
                    },
                }}
            >
                {/* Resize Handle */}
                <Box
                    ref={resizeRef}
                    onMouseDown={handleMouseDown}
                    onTouchStart={handleTouchStart}
                    sx={{
                        position: 'absolute',
                        left: 0,
                        top: 0,
                        bottom: 0,
                        width: '8px',
                        cursor: 'col-resize',
                        backgroundColor: 'transparent',
                        zIndex: 1300,
                        '&:hover': {
                            backgroundColor: 'rgba(33, 150, 243, 0.15)',
                            '& .resize-indicator': {
                                backgroundColor: '#2196f3',
                                width: '3px'
                            }
                        },
                        '&:active': {
                            backgroundColor: 'rgba(33, 150, 243, 0.2)',
                        },
                        ...(isResizing && {
                            backgroundColor: 'rgba(33, 150, 243, 0.25)',
                            '& .resize-indicator': {
                                backgroundColor: '#1976d2',
                                width: '4px'
                            }
                        }),
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        userSelect: 'none'
                    }}
                >
                    <Box
                        className="resize-indicator"
                        sx={{
                            width: '2px',
                            height: '60px',
                            backgroundColor: '#e0e0e0',
                            borderRadius: '1px',
                            transition: 'all 0.2s ease',
                            pointerEvents: 'none'
                        }}
                    />
                </Box>

                {/* Header */}
                <Box sx={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    padding: '16px',
                    backgroundColor: '#f5f5f5',
                    borderBottom: '1px solid #e0e0e0',
                    paddingLeft: '24px' // Account for resize handle
                }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Typography variant="h6" sx={{ fontWeight: 600, color: '#2c3e50' }}>
                            Live Preview
                        </Typography>
                        {!isMobile && (
                            <Tooltip title="Drag to resize" placement="top">
                                <DragIndicatorIcon sx={{ color: '#999', fontSize: 16 }} />
                            </Tooltip>
                        )}
                    </Box>
                    <IconButton onClick={onToggle} size="small">
                        <ChevronRightIcon />
                    </IconButton>
                </Box>

                <Divider />

                {/* Content */}
                <Box sx={{
                    height: 'calc(100vh - 70px - 73px)', // Account for header (70px) and drawer header (73px)
                    overflow: 'hidden',
                    paddingLeft: '8px' // Account for resize handle
                }}>
                    {nodes.length > 0 ? (
                        <TableView
                            nodes={nodes}
                            edges={edges}
                            onUpdateNode={onUpdateNode}
                            onDeleteNode={onDeleteNode}
                            onAddNode={onAddNode}
                            onUpdateEdges={onUpdateEdges}
                        />
                    ) : (
                        <Box sx={{
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            justifyContent: 'center',
                            height: '100%',
                            color: '#666',
                            textAlign: 'center',
                            padding: '20px'
                        }}>
                            <VisibilityIcon sx={{ fontSize: 48, marginBottom: 2, opacity: 0.5 }} />
                            <Typography variant="h6" sx={{ marginBottom: 1 }}>
                                No Questions Yet
                            </Typography>
                            <Typography variant="body2">
                                Add questions to see the live preview
                            </Typography>
                        </Box>
                    )}
                </Box>
            </Drawer>
        </>
    );
};

export default FlowPreviewDrawer;