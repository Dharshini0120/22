
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { v4 as uuidv4 } from 'uuid';
import { NewAssessment, NewAssessmentDocument } from '../entities/new-assessment.entity';
import { NewAssessmentService } from './new-assessment.service';
import { User, UserDocument } from '../entities/user.entity';
import { Transaction, TransactionDocument } from '../entities/transaction.entity';
import { S3Client, PutObjectCommand, HeadObjectCommand } from '@aws-sdk/client-s3';
import puppeteer from 'puppeteer';
import { EmailService } from '@app/email';
import { AdminUser } from '../entities/adminuser.entity';

// Note: This service builds a minimal HTML from assessment data.
// PDF generation is separated to allow swapping engines if needed.

@Injectable()
export class ReportService {
  private s3Client: S3Client;
  private readonly spacesEndpoint = 'https://sfo3.digitaloceanspaces.com';
  private readonly bucketName = 'hospital-assessment-tool';
  private readonly spacesRegion = 'sfo3';

  constructor(
    @InjectModel(AdminUser.name) private adminModel: Model<AdminUser>,
    @InjectModel(NewAssessment.name) private readonly newAssessmentModel: Model<NewAssessmentDocument>,
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
    @InjectModel(Transaction.name) private readonly transactionModel: Model<TransactionDocument>,
    private readonly newAssessmentService: NewAssessmentService,
    private readonly emailService: EmailService,
  ) {
    // Initialize DigitalOcean Spaces (S3-compatible)
    console.log('üîß Initializing DigitalOcean Spaces S3 Client...');
    console.log('üìç Endpoint:', this.spacesEndpoint);
    console.log('ü™£ Bucket:', this.bucketName);

    this.s3Client = new S3Client({
      region: this.spacesRegion,
      endpoint: this.spacesEndpoint,
      credentials: {
        accessKeyId: process.env.DO_SPACES_ACCESS_KEY || 'DO801LT6W6UV3KG4AU72',
        secretAccessKey: process.env.DO_SPACES_SECRET_KEY || 'lHC6Cg9oVLV5TI9NhH7HAY4O0xkE8thPrIf/ijXxvxY',
      }
    });

    console.log('‚úÖ S3 Client initialized successfully');
  }

  async buildAssessmentHtml(assessmentId: string): Promise<string> {
    
    const result = await this.newAssessmentService.getAssessments(assessmentId);
    if (result.status !== 'success' || !result.assessment) {
      throw new Error('Failed to retrieve assessment data');
    }
    console.log("********test3333********", result.assessment.sections);
    const questionNodes = result.assessment.sections[0].questionnaire?.nodes || [];
    const questionsMap = new Map<string, string>();
    for (const node of questionNodes) {
      if (node.type === 'questionNode' && node.data?.question) {
        questionsMap.set(node.id, node.data.question);
      }
    }

    const assessment = result.assessment;
    const rows: Array<{ number: string; question: string; answer: string; score: number; benchmark: number }> = [];

    let questionCounter = 1;
    for (const section of assessment.sections || []) {
      const answers: any[] = Array.isArray(section.answers) ? section.answers : [];
      const questionNodes = section.questionnaire?.nodes || [];  // get nodes from current section

      for (const ans of answers) {
        const qid = ans?.questionId ?? String(questionCounter);
        const qtext = questionsMap.get(qid) ?? ans?.questionText ?? ans?.question ?? '‚Äî';
        const atext = ans?.answerText ?? ans?.answer ?? '‚Äî';

        // Find the question node by id **in the current section**
        const questionNode = questionNodes.find(node => node.id === qid);

        let score = 0;
        let benchmark = 0;

        if (questionNode?.data?.optionsData && atext) {
          // Normalize strings for matching
          const answerNormalized = atext.trim().toLowerCase();

          // Find option where text matches answer text (case-insensitive)
          const matchedOption = questionNode.data.optionsData.find((opt: any) => {
            return opt.text.trim().toLowerCase() === answerNormalized;
          });

          if (matchedOption) {
            // Use the score directly from the matched option in optionsData
            score = parseFloat(matchedOption.score) || 0;
          }

          // Calculate benchmark as max score of options
          benchmark = questionNode.data.optionsData.reduce((max: number, opt: any) => {
            const s = parseFloat(opt.score) || 0;
            return s > max ? s : max;
          }, 0);
        }


        rows.push({ number: String(qid), question: qtext, answer: String(atext), score, benchmark });
        questionCounter++;
      }
    }


    const totalScore = rows.reduce((sum, r) => sum + (isFinite(r.score) ? r.score : 0), 0);

    // averageScore is all question answered score (total sum, not average)
    const averageScore = totalScore;

    // maxSingleQuestionScore = sum of max scores from each question's optionsData
    let maxSingleQuestionScore = 0;
    for (const section of assessment.sections || []) {
      const questionNodes = section.questionnaire?.nodes || [];
      for (const node of questionNodes) {
        if (node.type === 'questionNode' && node.data?.optionsData) {
          console.log("Options:", node.data.optionsData.map((opt: any) => ({
            text: opt.text,
            score: parseFloat(opt.score) || 0
          })));

          // Find max score from this question's options
          const totalScoreForThisQuestion = node.data.optionsData.reduce((max: number, opt: any) => {
            const s = parseFloat(opt.score) || 0;
            return s > max ? s : max;
            //return sum + s;
          }, 0);

          maxSingleQuestionScore += totalScoreForThisQuestion;
        }
      }
    }

    const pct = maxSingleQuestionScore > 0 ? Math.min(100, Math.max(0, (averageScore / maxSingleQuestionScore) * 100)) : 0;

    const benchAvg = rows.length
      ? rows.reduce((s, r) => s + (isFinite(r.benchmark) ? r.benchmark : 0), 0) / rows.length
      : 0;

    // Calculate Leapfrog and CentralDB benchmark scores
    let leapfrogScore = 0;
    let leapfrogMaxScore = 0;
    let leapfrogCount = 0;

    let centralDBScore = 0;
    let centralDBMaxScore = 0;
    let centralDBCount = 0;

    // Process each section to calculate benchmark-specific scores
    for (const section of assessment.sections || []) {
      const questionNodes = section.questionnaire?.nodes || [];
      for (const node of questionNodes) {
        if (node.type === 'questionNode' && node.data?.optionsData) {
          const benchmark = node.data?.benchmark;

          // Find the answered option for this question
          const answeredOption = section.answers?.find(ans => ans.questionId === node.id);
          let questionScore = 0;

          if (answeredOption) {
            const selectedOption = node.data.optionsData.find((opt: any) =>
              opt.text.trim().toLowerCase() === answeredOption.answer.trim().toLowerCase()
            );
            if (selectedOption) {
              questionScore = parseFloat(selectedOption.score) || 0;
            }
          }

          // Get sum of all option scores for this question (total possible)
          const allOptionScoresSum = node.data.optionsData.reduce((max: number, opt: any) => {
            const s = parseFloat(opt.score) || 0;
            return s > max ? s : max;
            //return sum + s;
          }, 0);

          // Add to leapfrog if benchmark.leapfrog is true
          if (benchmark?.leapfrog === true) {
            leapfrogScore += questionScore; // Sum of answered question option scores
            leapfrogMaxScore += allOptionScoresSum; // Sum of all question all option scores
            leapfrogCount++;
          }

          // Add to centralDB if benchmark.centralDB is true
          if (benchmark?.centralDB === true) {
            centralDBScore += questionScore; // Sum of answered question option scores
            centralDBMaxScore += allOptionScoresSum; // Sum of all question all option scores
            centralDBCount++;
          }
        }
      }
    }
    console.log("********testleap********", leapfrogScore, leapfrogMaxScore, centralDBScore, centralDBMaxScore);
    console.log(`üìä Leapfrog: ${leapfrogScore}/${leapfrogMaxScore} (${leapfrogCount} questions)`);
    console.log(`üìä CentralDB: ${centralDBScore}/${centralDBMaxScore} (${centralDBCount} questions)`);

    // Calculate indicator positions based on actual scores
    const leapfrogPercentage = leapfrogMaxScore > 0 ? (leapfrogScore / leapfrogMaxScore) * 100 : 0;
    const centralDBPercentage = centralDBMaxScore > 0 ? (centralDBScore / centralDBMaxScore) * 100 : 0;
    const othersPercentage = pct; // Use the percentage from total score
    const leapfrogIndicatorPos = Math.max(0, Math.min(100, leapfrogPercentage));
    const centralDBIndicatorPos = Math.max(0, Math.min(100, centralDBPercentage));
    const othersIndicatorPos = Math.max(0, Math.min(100, othersPercentage));

    // Format scores to 2 decimal places
    const leapfrogScoreFormatted = leapfrogScore.toFixed(2);
    const leapfrogMaxScoreFormatted = leapfrogMaxScore.toFixed(2);
    const centralDBScoreFormatted = centralDBScore.toFixed(2);
    const centralDBMaxScoreFormatted = centralDBMaxScore.toFixed(2);
    const averageScoreFormatted = averageScore.toFixed(2);
    const maxSingleQuestionScoreFormatted = maxSingleQuestionScore.toFixed(2);

    const escapeHtml = (unsafe: string) => unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

    const rowsHtml = rows.map(r => {
      const cls = r.score >= 0.8 ? 'score-high'
        : r.score >= 0.7 ? 'score-medium-high'
          : r.score >= 0.66 ? 'score-medium'
            : r.score >= 0.5 ? 'score-low-medium'
            : r.score >= 0.4 ? 'score-lowmiddle-medium'
              : r.score >= 0.35 ? 'score-low'
              : r.score >= 0.1 ? 'score-middle-low'
                : 'score-very-low';
      const benchLeft = Math.min(100, Math.max(0, r.score * 100));
      return `
        <tr>
          <td>${r.number}</td>
          <td>${escapeHtml(r.question)}</td>
          <td>${escapeHtml(r.answer)}</td>
          <td class="score-cell ${cls}">${r.score}</td>
          <td class="benchmark-visual">
            <div class="mini-benchmark">
              <div class="mini-segment segment-red"></div>
              <div class="mini-segment segment-orange"></div>
              <div class="mini-segment segment-green"></div>
              <div class="mini-marker" style="left: ${benchLeft}%;"></div>
            </div>
          </td>
        </tr>
      `;
    }).join('\n');

    // Example dummy time series data (replace later with actual historical)
const monthlyScores = [
  { month: 'Jan', score: 22 },
  { month: 'Feb', score: 25 },
  { month: 'Mar', score: 28 },
  { month: 'Apr', score: 26 },
  { month: 'May', score: 30 },
  { month: 'Jun', score: 29 }
];

// Example previous assessment comparison (you can load from DB)
const previousScores = {
  leapfrog: 65,
  cms: 70,
  others: 60
};
const currentScores = {
  leapfrog: (leapfrogScore / leapfrogMaxScore) * 100 || 0,
  cms: (centralDBScore / centralDBMaxScore) * 100 || 0,
  others: pct // reuse your total %
};

    const reportStyles = `<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            min-height: 100vh;
            background-color: #f5f5f5;
            padding: 24px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

         .section-header {
            background: #4A90E2;
            color: white;
            padding: 12px 20px;
            font-weight: 600;
            font-size: 14px;
        }

          .section-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }
        
        .table-header {
            background: #E3F2FD;
        }
        
        .table-header th {
            width: 10%;
            padding: 12px 15px;
            text-align: left;
            font-weight: 500;
            font-size: 12px;
            color: #1976D2;
            border-bottom: 1px solid #BBDEFB;
            border-right: 1px solid #BBDEFB;
        }
        
        .table-header th:last-child {
            border-right: none;
        }
        
        .table-row {
            border-bottom: 1px solid #f0f0f0;
        }
        
        .table-row:hover {
            background: #fafafa;
        }
        
        .table-row td {
            padding: 12px 15px;
            font-size: 12px;
            vertical-align: middle;
            border-right: 1px solid #f0f0f0;
        }
        
        .table-row td:last-child {
            border-right: none;
        }
        .hospital-header {
            margin-bottom: 8px;
        }

        .hospital-name {
            font-size: 18px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 4px;
        }

        .hospital-address {
            font-size: 12px;
            color: #666;
            margin-bottom: 16px;
        }

        .report-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 24px;
        }

        // .cards-container {
        //     display: grid;
        //     grid-template-columns: 300px 1fr;
        //     gap: 24px;
        //     margin-bottom: 24px;
        // }

        // .card {
        //     background-color: #fff;
        //     border-radius: 8px;
        //     padding: 20px;
        //     box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        // }

        // .benchmark-card {
        //     background-color: #fff;
        //     border-radius: 8px;
        //     padding: 20px;
        //     box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        //     display: grid;
        //     grid-template-columns: 1fr 1fr;
        //     gap: 40px;
        //     align-items: center;
        // }

     .top-grid {
     display: grid;
     grid-template-columns: 220px 1fr;
    /* score + chart side by side */
     gap: 20px;
     align-items: stretch;
    /* make both columns same height */
}
/* Make both cards stretch evenly */
 .score-card, .chart-section {
     display: flex;
     flex-direction: column;
     justify-content: space-between;
     height: 200px;
}
/* Fill vertical space evenly inside score card */
 .score-card {
     background-color: #fff;
     border-radius: 8px;
     padding: 16px 18px;
     box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
/* Push the progress bar and labels closer to bottom */
 .score-value {
     font-size: 30px;
     font-weight: 600;
     color: #333;
     margin-bottom: 8px;
    /* allow natural stretch */
}
/* Make chart height match */
 .chart-section {
     background: #fff;
     border-radius: 8px;
     padding: 12px 16px 10px 16px;
     box-shadow: 0 1px 3px rgba(0,0,0,0.05);
     height:200px;
     display: flex;
     flex-direction: column;
     justify-content: space-between;
}
/* Keep legend tight below chart */
 .chart-section canvas {
     width: 100% !important;
     height: 200px !important;
     border-radius: 8px;
     display: block;
}
 .benchmark-card {
     display: grid;
     grid-template-columns: 1fr 1fr 1fr;
     gap: 20px;
     margin-bottom: 24px;
}

        .benchmark-item {
            flex: 1;
            text-align: center;
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .benchmark-section-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
        }

        .benchmark-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .benchmark-bar {
            position: relative;
            height: 12px;
            background: linear-gradient(90deg, #ff6b6b 0%, #ffa726 25%, #ffeb3b 50%, #66bb6a 75%, #4caf50 100%);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .benchmark-indicator {
            position: absolute;
            top: 1px;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 8px solid #333;
        }

        .benchmark-leapfrog .benchmark-indicator {
            left: var(--leapfrog-pos, 76.7%);
            transform: translateX(-50%) translateY(-50%);
        }

        .benchmark-cms .benchmark-indicator {
            left: var(--cms-pos, 80%);
            transform: translateX(-50%) translateY(-50%);
        }

        .benchmark-others .benchmark-indicator {
            left: var(--others-pos, 0%);
            transform: translateX(-50%) translateY(-50%);
        }

        .benchmark-score {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .score-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }

        .score-icon {
            width: 16px;
            height: 16px;
            background-color: #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 10px;
            font-weight: 600;
        }

        .score-label {
            font-size: 13px;
            color: #111827;
            font-weight: 600;
        }

        .score-value {
            font-size: 30px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .score-value .total {
            color: #999;
        }

        .progress-bar-container {
            position: relative;
            height: 6px;
           // margin-top: 16px;
            //margin-bottom: 6px;
        }

        .progress-bar-bg {
            position: absolute;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(to right, #e74c3c 0%, #e74c3c 35%, #95a5a6 35%, #95a5a6 100%);
            border-radius: 3px;
        }

        .progress-bar-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 6px;
            width: 66%;
            background: linear-gradient(to right, #3498db 0%, #3498db 100%);
            border-radius: 3px;
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #999;
        }

        .table-container {
            background-color: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        tbody tr {
            border-bottom: 1px solid #e0e0e0;
        }

        tbody tr:last-child {
            border-bottom: none;
        }

        td {
            padding: 12px 16px;
            font-size: 13px;
            color: #333;
            border-right: 1px solid #e0e0e0;
        }

        td:last-child {
            border-right: none;
        }

        td.score-cell {
            font-size: 14px;
            font-weight: 600;
            text-align: center;
        }

        .score-high {
            background-color: #90ee90;
        }

        .score-medium-high {
            background-color: #b3f5b3;
        }

        .score-medium {
            background-color: #d4f7d4;
        }

        .score-low-medium {
            background-color: #ffc355ff;
        }

        .score-lowmiddle-medium {
            background-color: rgba(252, 181, 111, 1);
        }

        .score-low {
            background-color: #ffd2a6ff;
        }

        .score-middle-low{
            background-color: #ffb3b3;
        }

        .score-very-low {
            background-color: #fd6060ff;
        }

        //  .benchmark-visual {
        //     width: 180px;
        //     position: relative;
        //     padding: 15px 6px 5px 6px;
        // }
        .benchmark-visual {
    width: 100%;
    max-width: 100%;
    padding: 20px 10px 20px 10px;
    margin-left: 0;
}
        
          .segment-red { 
            border-radius: 5px; 
            background: #ef4444; 
        }
        .segment-orange { 
            border-radius: 5px;
             background: #f97316; 
            }
        .segment-green { 
            border-radius: 5px; 
            background: #22c55e;
        }
        .mini-benchmark {
            display: flex;
            gap: 5px;
            height: 8px;
            position: relative;
        }
        
        .mini-segment {
            flex: 1;
            height: 100%;
        }
        
        .mini-marker {
            position: absolute;
            top: -3px;
            width: 15px;
            height: 15px;
            background: white;
            border: 3px solid #4A90E2;
            border-radius: 50%;
            transform: translateX(-50%);
        }
        .chart-section {
  position: relative;
  width: 100%;
  background: #fff;
  border-radius: 8px;
  padding: 12px 16px 12px 16px;
  margin-bottom: 24px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  overflow: hidden; /* ‚úÖ prevents canvas overflow */
}

.chart-section h3 {
  font-size: 13px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 10px;
}

.chart-section canvas {
  width: 100% !important;   /* ‚úÖ make canvas fit parent width */
  height: 180px !important; /* ‚úÖ fix height inside the card */
  display: block;
  border-radius: 8px;
}


    </style>`;

    const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hospital Infection Prevention Assessment Report</title>
    ${reportStyles}
</head>
<body>
   
    <!-- Report Title -->
    <h1 class="report-title">Hospital Infection Prevention Assessment Report TEST</h1>
    
 <!-- === NEW LAYOUT START === -->
<!-- Top Row: Average Score (left) + Graph (right) -->
<div class="top-grid">
  <!-- Score Card -->
  <div class="score-card">
    <div class="score-header">
      <div class="score-icon">‚âà</div>
      <span class="score-label">Average Score</span>
    </div>
    <div class="score-value">${averageScoreFormatted} <span class="total">/ ${maxSingleQuestionScoreFormatted}</span></div>
    <div class="progress-bar-container">
      <div class="progress-bar-bg"></div>
      <div class="progress-bar-fill" style="width: ${pct}%;"></div>
    </div>
    <div class="progress-labels">
      <span>0</span>
      <span>100%</span>
    </div>
  </div>

  <!-- Graphical Representation -->
  <div class="chart-section">
    <h3>Graphical Representation</h3>
    <canvas id="scoreChart" width="900" height="280"></canvas>
  </div>
</div>

<!-- Bottom Row: Benchmarks Current -->
<div class="benchmark-section-title">Current</div>
<div class="benchmark-card">
  <div class="benchmark-item benchmark-leapfrog">
    <div class="benchmark-title">Benchmark Leapfrog</div>
    <div class="benchmark-bar" style="--leapfrog-pos: ${leapfrogIndicatorPos}%;"><div class="benchmark-indicator"></div></div>
    <div class="benchmark-score">${leapfrogScoreFormatted}/${leapfrogMaxScoreFormatted}</div>
  </div>

  <div class="benchmark-item benchmark-cms">
    <div class="benchmark-title">CMS/NHSN</div>
    <div class="benchmark-bar" style="--cms-pos: ${centralDBIndicatorPos}%;"><div class="benchmark-indicator"></div></div>
    <div class="benchmark-score">${centralDBScoreFormatted}/${centralDBMaxScoreFormatted}</div>
  </div>

  <div class="benchmark-item benchmark-others">
    <div class="benchmark-title">Others</div>
    <div class="benchmark-bar" style="--others-pos: ${othersIndicatorPos}%;"><div class="benchmark-indicator"></div></div>
    <div class="benchmark-score">${averageScoreFormatted}/${maxSingleQuestionScoreFormatted}</div>
  </div>
</div>

<!-- Bottom Row: Benchmarks Previous  -->
<div class="benchmark-section-title">Previous</div>
<div class="benchmark-card">
  <div class="benchmark-item benchmark-leapfrog">
    <div class="benchmark-title">Benchmark Leapfrog</div>
    <div class="benchmark-bar" style="--leapfrog-pos: ${leapfrogIndicatorPos}%;"><div class="benchmark-indicator"></div></div>
    <div class="benchmark-score">${leapfrogScoreFormatted}/${leapfrogMaxScoreFormatted}</div>
  </div>

  <div class="benchmark-item benchmark-cms">
    <div class="benchmark-title">CMS/NHSN</div>
    <div class="benchmark-bar" style="--cms-pos: ${centralDBIndicatorPos}%;"><div class="benchmark-indicator"></div></div>
    <div class="benchmark-score">${centralDBScoreFormatted}/${centralDBMaxScoreFormatted}</div>
  </div>

  <div class="benchmark-item benchmark-others">
    <div class="benchmark-title">Others</div>
    <div class="benchmark-bar" style="--others-pos: ${othersIndicatorPos}%;"><div class="benchmark-indicator"></div></div>
    <div class="benchmark-score">${averageScoreFormatted}/${maxSingleQuestionScoreFormatted}</div>
  </div>
</div>

<!-- === NEW LAYOUT END === -->


    <!-- Table -->
    <div class="table-container">
         <div class="section-header">${result.assessment.sectionName}</div>
           <table class="section-table">
                <thead class="table-header">
                    <tr>
                        <th style="width:3%">#</th>
                        <th style="width:45%">Question</th>
                        <th style="width:9%">Response</th>
                        <th style="width:8%">Score</th>
                      <th style="width:38%">Benchmark</th>
                    </tr>
                </thead>
            <tbody>
                ${rowsHtml}
            </tbody>
        </table>
    </div>
 <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  // Labels for full Jan‚ÄìDec range
  const labels = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  // Replace these arrays with your real computed monthly values from backend
  const cmsData = [3, 4, 4.5, 5, 4.2, 5.1, 4.8, 4.9, 5.2, 5.3, 5.0, 4.8];
  const leapfrogData = [5, 6, 6.3, 6.1, 6.4, 6.2, 6.5, 6.4, 6.6, 6.7, 6.8, 6.9];
  const othersData = [1.5, 1.8, 1.6, 1.9, 2.1, 2.2, 2.3, 2.2, 2.4, 2.3, 2.5, 2.6];
  const totalScoreData = [15, 16, 17, 16, 17.5, 18, 17.8, 18, 18.3, 18.5, 18.2, 18.4];

  const ctx = document.getElementById('scoreChart').getContext('2d');
new Chart(ctx, {
  type: 'line',
  data: {
    labels: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
    datasets: [
      {
        label: 'CMS/NHSN',
        data: cmsData,
        borderColor: '#fbbf24',
        backgroundColor: 'transparent',
        borderWidth: 2,
        tension: 0.3,
        pointRadius: 3.5,
        pointBorderWidth: 2,
        pointBackgroundColor: '#fff',
        pointBorderColor: '#fbbf24',
        fill: false
      },
      {
        label: 'Leapfrog',
        data: leapfrogData,
        borderColor: '#22c55e',
        backgroundColor: 'transparent',
        borderWidth: 2,
        tension: 0.3,
        pointRadius: 3.5,
        pointBorderWidth: 2,
        pointBackgroundColor: '#fff',
        pointBorderColor: '#22c55e',
        fill: false
      },
      {
        label: 'Others',
        data: othersData,
        borderColor: '#ef4444',
        backgroundColor: 'transparent',
        borderWidth: 2,
        tension: 0.3,
        pointRadius: 3.5,
        pointBorderWidth: 2,
        pointBackgroundColor: '#fff',
        pointBorderColor: '#ef4444',
        fill: false
      },
      {
        label: 'Total Score',
        data: totalScoreData,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59,130,246,0.1)',
        borderWidth: 2,
        tension: 0.3,
        pointRadius: 4,
        pointBorderWidth: 2,
        pointBackgroundColor: '#fff',
        pointBorderColor: '#3b82f6',
        fill: true
      }
    ]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    layout: {
      // padding: { top: 10, left: 15, right: 15, bottom: 10 }
       padding: 0
    },
  plugins: {
  legend: {
    display: true,
    position: 'bottom',
    padding: { top: 10, bottom: 0, left: 0, right: 0 },
    labels: {
      usePointStyle: true,
      pointStyle: 'circle',
      boxWidth: 10,
      boxHeight: 10,
      font: { size: 11 },
      padding: 15,
      marginTop: 2,
      // ‚úÖ dynamically color each label text based on its line color
      generateLabels: (chart) => {
        const datasets = chart.data.datasets;
        return datasets.map((dataset, i) => ({
          text: dataset.label,
          fillStyle: "white",
          strokeStyle: dataset.borderColor,
          fontColor: dataset.borderColor,  // optional for clarity
          hidden: !chart.isDatasetVisible(i),
          datasetIndex: i,
          lineWidth: 2,
        }));
      },
      // ‚úÖ ensures text matches dataset color
      color: (context) => {
        const dataset = context.chart.data.datasets[context.datasetIndex];
        return dataset ? dataset.borderColor : '#333';
      },
    }
  }
},

    scales: {
      x: {
        offset: false,
        grid: { color: '#f5f5f5', drawBorder: true },
        ticks: {
          color: '#666',
          font: { size: 10 },
          padding: 6,
          align: 'center'
        },
        border: { display: true, color: '#ddd', width: 1 }
      },
      y: {
        beginAtZero: true,
        grid: { color: '#eee' },
        ticks: { color: '#666', font: { size: 10 } },
        max: 30
      }
    },
    elements: {
      line: {
        borderJoinStyle: 'round'
      },
      point: {
        z: 10   // ‚úÖ ensures point sits above line
      }
    }
  }
});

</script>


</body>
</html>`;

    return html;
  }

  /**
   * Generate benchmark report comparing three ranges with normalized calculations
   */
  generateBenchmarkReport(): string {
    // Sample data - can be modified later
    const benchmarkData = [
      {
        range: '0‚Äì1',
        maxValue: 1,
        markers: [0.95, 0.90, 1.00],
        color: 'green'
      },
      {
        range: '0‚Äì0.98',
        maxValue: 0.98,
        markers: [0.84, 0.70, 0.91],
        color: 'yellow'
      },
      {
        range: '0‚Äì0.48',
        maxValue: 0.48,
        markers: [0.20, 0.35, 0.30],
        color: 'red'
      }
    ];

    const processedData = benchmarkData.map(data => {
      // Normalize each marker using normalized = marker_value / benchmark_max
      const normalizedValues = data.markers.map(marker => marker / data.maxValue);

      // Compute the average of normalized values
      const normalizedAverage = normalizedValues.reduce((sum, val) => sum + val, 0) / normalizedValues.length;

      // Multiply the normalized average by the benchmark maximum to get the actual average marker value
      const actualAverageMarker = normalizedAverage * data.maxValue;

      // Calculate progress percentage
      const progressPercentage = (actualAverageMarker / data.maxValue) * 100;

      // Determine performance color
      let performanceColor = 'red';
      if (progressPercentage >= 90) performanceColor = 'green';
      else if (progressPercentage >= 60) performanceColor = 'yellow';

      return {
        ...data,
        normalizedValues,
        normalizedAverage,
        actualAverageMarker,
        progressPercentage,
        performanceColor
      };
    });

    const benchmarkStyles = `
      <style>
        .benchmark-report {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          max-width: 1200px;
          margin: 20px auto;
          padding: 20px;
          background: #f8f9fa;
        }
        .benchmark-title {
          font-size: 24px;
          font-weight: 600;
          color: #333;
          margin-bottom: 30px;
          text-align: center;
        }
        .benchmark-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }
        .benchmark-card {
          background: white;
          border-radius: 12px;
          padding: 24px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          border-left: 4px solid;
        }
        .benchmark-card.green { border-left-color: #22c55e; }
        .benchmark-card.yellow { border-left-color: #f59e0b; }
        .benchmark-card.red { border-left-color: #ef4444; }

        .range-header {
          font-size: 18px;
          font-weight: 600;
          margin-bottom: 16px;
          color: #333;
        }
        .markers-list {
          margin-bottom: 16px;
        }
        .markers-title {
          font-size: 14px;
          font-weight: 500;
          color: #666;
          margin-bottom: 8px;
        }
        .markers-values {
          display: flex;
          gap: 8px;
          flex-wrap: wrap;
        }
        .marker-value {
          background: #f1f5f9;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
          font-weight: 500;
        }
        .metric-row {
          display: flex;
          justify-content: space-between;
          margin-bottom: 8px;
          font-size: 14px;
        }
        .metric-label {
          color: #666;
          font-weight: 500;
        }
        .metric-value {
          color: #333;
          font-weight: 600;
        }
        .progress-container {
          margin-top: 16px;
        }
        .progress-bar {
          width: 100%;
          height: 8px;
          background: #e5e7eb;
          border-radius: 4px;
          overflow: hidden;
          margin-bottom: 8px;
        }
        .progress-fill {
          height: 100%;
          border-radius: 4px;
          transition: width 0.3s ease;
        }
        .progress-fill.green { background: #22c55e; }
        .progress-fill.yellow { background: #f59e0b; }
        .progress-fill.red { background: #ef4444; }
        .progress-text {
          text-align: center;
          font-size: 12px;
          color: #666;
        }

        .chart-container {
  background: #fff;
  border-radius: 8px;
  padding: 16px 20px;
  margin-bottom: 24px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.chart-container h3 {
  font-size: 14px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 12px;
}

      </style>
    `;

    const cardsHtml = processedData.map(data => `
      <div class="benchmark-card ${data.performanceColor}">
        <div class="range-header">Benchmark Range: ${data.range}</div>

        <div class="markers-list">
          <div class="markers-title">Marker Values:</div>
          <div class="markers-values">
            ${data.markers.map(marker => `<span class="marker-value">${marker}</span>`).join('')}
          </div>
        </div>

        <div class="metric-row">
          <span class="metric-label">Normalized Average:</span>
          <span class="metric-value">${data.normalizedAverage}</span>
        </div>

        <div class="metric-row">
          <span class="metric-label">Actual Average Marker:</span>
          <span class="metric-value">${data.actualAverageMarker}</span>
        </div>

        <div class="metric-row">
          <span class="metric-label">Progress Percentage:</span>
          <span class="metric-value">${data.progressPercentage}%</span>
        </div>

        <div class="progress-container">
          <div class="progress-bar">
            <div class="progress-fill ${data.performanceColor}" style="width: ${data.progressPercentage}%"></div>
          </div>
          <div class="progress-text">${data.actualAverageMarker} / ${data.maxValue}</div>
        </div>
      </div>
    `).join('');

    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Benchmark Report</title>
        ${benchmarkStyles}
      </head>
      <body>
        <div class="benchmark-report">
          <h1 class="benchmark-title">Benchmark Report Analysis</h1>
          <div class="benchmark-grid">
            ${cardsHtml}
          </div>
        </div>
      </body>
      </html>
    `;
  }

  /**
   * Generate and upload assessment report to DigitalOcean Spaces
   * @param assessmentId - Assessment ID
   * @param userId - User ID
   * @returns Report URL or error
   */
  async generateAndUploadReport(assessmentId: string, userId: string, forceRegenerate = false): Promise<{
    status: string;
    message: string;
    reportUrl?: string;
    error?: any;
  }> {
    try {
      console.log('üìÑ Starting report generation for assessment:', assessmentId);

      // Step 1: Get user details (facilityName)
      const user = await this.userModel.findById(userId).select('facilityName').exec();
      if (!user) {
        return {
          status: 'error',
          message: 'User not found',
          error: { code: 'USER_NOT_FOUND' }
        };
      }

      // Step 2: Get transaction with stripeInvoiceId
      const transaction = await this.transactionModel.findOne({
        assessmentId: assessmentId,
        userId: userId
      }).select('stripeInvoiceId').exec();

      if (!transaction || !transaction.stripeInvoiceId) {
        return {
          status: 'error',
          message: 'Transaction or invoice ID not found',
          error: { code: 'TRANSACTION_NOT_FOUND' }
        };
      }

      // Step 3: Check if report already exists in DigitalOcean Spaces
      const facilityName = user.facilityName.replace(/\s+/g, '_'); // Replace spaces with underscores
      const reportId = uuidv4();
      const fileName = `Reports/${reportId}/${transaction.stripeInvoiceId}.pdf`;
      const reportUrl = `${this.spacesEndpoint}/${this.bucketName}/${fileName}`;

      const fileExists = await this.checkFileExists(fileName);
      if (fileExists && !forceRegenerate) {
        console.log('‚úÖ Report already exists at:', reportUrl);
        return {
          status: 'success',
          message: 'Report retrieved from cache',
          reportUrl: reportUrl
        };
      }

      // Step 4: Generate HTML report
      const htmlReport = await this.buildAssessmentHtml(assessmentId);

      // Step 5: Convert HTML to PDF using Puppeteer
      const pdfBuffer = await this.htmlToPdf(htmlReport);

      // Step 6: Upload PDF to DigitalOcean Spaces
      await this.uploadToSpaces(fileName, pdfBuffer);

      console.log('‚úÖ Report uploaded successfully to:', reportUrl);

      // Step 7: Store reportUrl in assessment document
      await this.newAssessmentModel.findByIdAndUpdate(
        assessmentId,
        {
          reportUrl: reportUrl,
          reportGeneratedAt: new Date()
        },
        { new: true }
      );

      console.log('‚úÖ Report URL stored in assessment document');

      return {
        status: 'success',
        message: 'Report generated and uploaded successfully',
        reportUrl: reportUrl
      };

    } catch (error) {
      console.error('‚ùå Error generating/uploading report:', error);
      return {
        status: 'error',
        message: 'Failed to generate or upload report ttttff',
        error: {
          code: 'REPORT_GENERATION_ERROR',
          details: error.message
        }
      };
    }
  }

  /**
   * Send report via email to user
   * @param assessmentId - Assessment ID
   * @param userId - User ID
   * @returns Success or error response
   */
  async sendReportEmail(assessmentId: string, userId: string): Promise<{
    status: string;
    message: string;
    error?: any;
  }> {
    try {
      console.log('üìß Starting report email send for assessment:', assessmentId);

      // Get assessment
      const assessment = await this.newAssessmentModel.findById(assessmentId).exec();
      if (!assessment) {
        return {
          status: 'error',
          message: 'Assessment not found',
          error: { code: 'ASSESSMENT_NOT_FOUND' }
        };
      }

      // If report URL doesn't exist, generate it first
      let reportUrl = assessment.reportUrl;
      if (!reportUrl) {
        console.log('üìÑ Report URL not found, generating report...');
        const generateResult = await this.generateAndUploadReport(assessmentId, userId, true);
        reportUrl = generateResult.reportUrl;
      }

      // Get user details
      const user = await this.userModel.findById(userId).select('email fullName facilityName').exec();
      if (!user || !user.email) {
        return {
          status: 'error',
          message: 'User or email not found',
          error: { code: 'USER_NOT_FOUND' }
        };
      }

      // Get assessment name/section name and dates
      const assessmentData = await this.newAssessmentModel.findById(assessmentId).select('sectionName startedDate completedDate').exec();
      const assessmentName = assessmentData?.sectionName || 'Assessment Report';
      const startDate = assessmentData?.startedDate || new Date();
      const completedDate = assessmentData?.completedDate || new Date();

      // Format the dates
      const formattedStartDate = new Date(startDate).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      const formattedCompletedDate = new Date(completedDate).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      // Project logo URL from S3
      const projectLogoUrl = process.env.PROJECT_LOGO_URL || `${this.spacesEndpoint}/${this.bucketName}/logo/logo.png`;

      // Send email with report link
      const emailHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Assessment Report Ready</title>
    <!--[if mso]>
    <style type="text/css">
        body, table, td {font-family: Arial, Helvetica, sans-serif !important;}
    </style>
    <![endif]-->
</head>
<body style="margin: 0; padding: 0; background-color: #e8e8e8; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
    <!-- Wrapper Table -->
    <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="100%" style="background-color: #e8e8e8;">
        <tr>
            <td style="padding: 40px 20px;">
                <!-- Main Container -->
                <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="600" style="margin: 0 auto; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 600px;" class="email-container">
                    <!-- Logo Header -->
                    <tr>
                        <td style="padding: 30px 30px 20px 30px; text-align: center; border-radius: 8px 8px 0 0;">
                            <img src="${projectLogoUrl}" alt="Hospital Assessment Tool" style="max-width: 180px; height: auto; display: block; margin: 0 auto;">
                        </td>
                    </tr>

                    <!-- Body Content -->
                    <tr>
                        <td style="padding: 30px 30px;">
                            <!-- Greeting -->
                            <p style="margin: 0 0 20px 0; color: #0066cc; font-size: 16px; line-height: 1.6;">
                                Hello <strong>${user.fullName}</strong>,
                            </p>

                            <!-- Main Message -->
                            <p style="margin: 0 0 30px 0; color: #555555; font-size: 16px; line-height: 1.6;">
                                Your assessment report has been completed and is ready for download.
                            </p>

                            <!-- Assessment Details Box -->
                            <div style="border-left: 4px solid #0066cc; background-color: #f9f9f9; padding: 20px; margin: 0 0 30px 0; border-radius: 4px;">
                                <p style="margin: 0 0 15px 0; color: #333333; font-size: 14px; line-height: 1.6;">
                                    <strong style="color: #0066cc;">Assessment Name:</strong> <span style="color: #0066cc;">${assessmentName}</span>
                                </p>
                                <p style="margin: 0 0 15px 0; color: #333333; font-size: 14px; line-height: 1.6;">
                                    <strong style="color: #0066cc;">Facility:</strong> <span style="color: #0066cc;">${user.facilityName}</span>
                                </p>
                                <p style="margin: 0 0 15px 0; color: #333333; font-size: 14px; line-height: 1.6;">
                                    <strong style="color: #0066cc;">Started Date:</strong> <span style="color: #0066cc;">${formattedStartDate}</span>
                                </p>
                                <p style="margin: 0; color: #333333; font-size: 14px; line-height: 1.6;">
                                    <strong style="color: #0066cc;">Completed Date:</strong> <span style="color: #0066cc;">${formattedCompletedDate}</span>
                                </p>
                            </div>

                            <!-- Download Button -->
                            <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="100%">
                                <tr>
                                    <td style="text-align: center; padding: 20px 0;">
                                        <!--[if mso]>
                                        <v:roundrect xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" href="${reportUrl}" style="height:50px;v-text-anchor:middle;width:200px;" arcsize="10%" strokecolor="#4A90E2" fillcolor="#4A90E2">
                                            <w:anchorlock/>
                                            <center style="color:#ffffff;font-family:sans-serif;font-size:16px;font-weight:600;">Download Report</center>
                                        </v:roundrect>
                                        <![endif]-->
                                        <!--[if !mso]><!-->
                                        <a href="${reportUrl}" style="display: inline-block; background-color: #4A90E2; color: #ffffff; text-decoration: none; padding: 15px 40px; border-radius: 5px; font-size: 16px; font-weight: 600; border: 2px solid #4A90E2; transition: all 0.3s ease;">Download Report</a>
                                        <!--<![endif]-->
                                    </td>
                                </tr>
                            </table>

                            <!-- Validity Notice -->
                            <p style="margin: 20px 0 0 0; color: #cc0000; font-size: 14px; line-height: 1.6; text-align: center;">
                                This link is valid for 30 days.
                            </p>
                        </td>
                    </tr>

                    <!-- Footer -->
                    <tr>
                        <td style="background-color: #f5f5f5; padding: 30px; text-align: center; border-radius: 0 0 8px 8px;">
                            <p style="margin: 0; color: #999999; font-size: 12px; line-height: 1.5;">
                                ¬© 2024 Healthcare Assessment Tool. All rights reserved.
                            </p>
                        </td>
                    </tr>
                </table>

                <!-- Spacer for mobile -->
                <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="100%">
                    <tr>
                        <td style="padding: 20px 0; text-align: center;">
                            <p style="margin: 0; color: #999999; font-size: 12px; line-height: 1.5;">
                                If you have trouble clicking the button, copy and paste this URL into your browser:<br>
                                <a href="${reportUrl}" style="color: #0066cc; text-decoration: underline;">${reportUrl}</a>
                            </p>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</body>
</html>
`;


      await this.emailService.sendMail({
        to: user.email,
        subject: `Assessment Report - ${user.facilityName}`,
        html: emailHtml
      });

      console.log('‚úÖ Report email sent successfully to:', user.email);

      return {
        status: 'success',
        message: 'Report sent to email successfully'
      };

    } catch (error) {
      console.error('‚ùå Error sending report email:', error);
      return {
        status: 'error',
        message: 'Failed to send report email',
        error: {
          code: 'EMAIL_SEND_ERROR',
          details: error.message
        }
      };
    }
  }

  /**
   * Get report URL for assessment (optimized - single query)
   * @param assessmentId - Assessment ID
   * @returns Report URL or error response
   */
  async getReportUrl(assessmentId: string, userId: string): Promise<{
    status: string;
    message: string;
    reportUrl?: string;
    error?: any;
  }> {
    try {
      console.log('üîó Fetching report URL for assessment:', assessmentId);
     // FOR TESTING
       await this.generateAndUploadReport(
          assessmentId,
          userId,
          true
        );

      // Optimized: Only select reportUrl field to minimize data transfer
      const assessment = await this.newAssessmentModel
        .findById(assessmentId)
        .select('reportUrl')
        .lean()
        .exec();

      if (!assessment) {
        return {
          status: 'error',
          message: 'Assessment not found',
          error: { code: 'ASSESSMENT_NOT_FOUND' }
        };
      }
      

      if (!assessment.reportUrl) {
      console.log('üìÑ Generating report for assessment:', assessmentId, 'User:', userId);

        await this.generateAndUploadReport(
          assessmentId,
          userId,
          true
        );
        return {
          status: 'error',
          message: 'Report URL not available. Please generate the report first.',
          error: { code: 'REPORT_URL_NOT_FOUND' }
        };
      }

      console.log('‚úÖ Report URL retrieved successfully');

      return {
        status: 'success',
        message: 'Report URL retrieved successfully',
        reportUrl: assessment.reportUrl
      };

    } catch (error) {
      console.error('‚ùå Error fetching report URL:', error);
      return {
        status: 'error',
        message: 'Failed to fetch report URL',
        error: {
          code: 'FETCH_REPORT_URL_ERROR',
          details: error.message
        }
      };
    }
  }

  /**
   * Get secure download link for report (time-limited)
   * @param assessmentId - Assessment ID
   * @param expiryMinutes - Link expiry time in minutes (default: 1440 = 24 hours)
   * @returns Download link or error response
   */
  async getSecureDownloadLink(assessmentId: string, expiryMinutes: number = 1440): Promise<{
    status: string;
    message: string;
    downloadLink?: string;
    expiresAt?: Date;
    error?: any;
  }> {
    try {
      console.log('üîó Generating secure download link for assessment:', assessmentId);

      // Get assessment with reportUrl
      const assessment = await this.newAssessmentModel.findById(assessmentId).exec();
      if (!assessment || !assessment.reportUrl) {
        return {
          status: 'error',
          message: 'Assessment or report URL not found',
          error: { code: 'ASSESSMENT_NOT_FOUND' }
        };
      }

      // Calculate expiry time
    //  const expiresAt = new Date(Date.now() + expiryMinutes * 60 * 1000);

  //    console.log('‚úÖ Secure download link generated, expires at:', expiresAt);

      return {
        status: 'success',
        message: 'Download link generated successfully',
        downloadLink: assessment.reportUrl,
       // expiresAt: expiresAt
      };

    } catch (error) {
      console.error('‚ùå Error generating download link:', error);
      return {
        status: 'error',
        message: 'Failed to generate download link',
        error: {
          code: 'DOWNLOAD_LINK_ERROR',
          details: error.message
        }
      };
    }
  }

  /**
   * Check if file exists in DigitalOcean Spaces
   */
  private async checkFileExists(fileName: string): Promise<boolean> {
    try {
      const command = new HeadObjectCommand({
        Bucket: this.bucketName,
        Key: fileName
      });
      await this.s3Client.send(command);
      return true;
    } catch (error: any) {
      if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {
        return false;
      }
      throw error;
    }
  }

  /**
   * Convert HTML to PDF using Puppeteer
   */
  private async htmlToPdf(html: string): Promise<Buffer> {
    let browser: any;
    try {
      console.log('üöÄ Launching Puppeteer browser with enhanced rendering...');

      // Determine the executable path
      let executablePath = process.env.PUPPETEER_EXECUTABLE_PATH;

      if (!executablePath) {
        // Try common Chrome/Chromium locations on Linux (prioritize Google Chrome)
        const possiblePaths = [
          '/usr/bin/google-chrome-stable',
          '/usr/bin/google-chrome',
          '/snap/bin/chromium',
          '/usr/bin/chromium-browser',
          '/usr/bin/chromium',
        ];

        const fs = require('fs');

        for (const chromePath of possiblePaths) {
          try {
            // Use accessSync to check if file exists and is executable
            fs.accessSync(chromePath, fs.constants.F_OK);
            executablePath = chromePath;
            console.log(`‚úÖ Found Chrome/Chromium at: ${chromePath}`);
            break;
          } catch (e) {
            console.log(`‚ö†Ô∏è Chrome not found at ${chromePath}`);
          }
        }

        if (!executablePath) {
          console.warn('‚ö†Ô∏è No Chrome/Chromium found in common paths. Using default Puppeteer path.');
          // Force use of system Chrome if available, otherwise let Puppeteer handle it
          executablePath = '/usr/bin/google-chrome-stable';     
        }
      }

      console.log(`üìç Using executable path: ${executablePath}`);

      browser = await puppeteer.launch({
        // if server enable below
        headless: true,
        // executablePath:  process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/google-chrome-stable' || '/usr/bin/chromium-browser'  ,
        executablePath:  'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
        // args: [
        //   '--no-sandbox',
        //   '--disable-setuid-sandbox',
        //   '--disable-dev-shm-usage',
        //   '--disable-accelerated-2d-canvas',
        //   '--no-first-run',
        //   '--no-zygote',
        //   '--single-process',
        //   '--disable-gpu',
        //   '--disable-background-timer-throttling',
        //   '--disable-backgrounding-occluded-windows',
        //   '--disable-renderer-backgrounding',
        //   '--font-render-hinting=none',
        //   '--disable-blink-features=AutomationControlled',
        // ],
        // FOR TESTING
   //     if local enable below  
         args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
        ]
      });


    const page = await browser.newPage();

    // ‚úÖ Ensure full-size viewport (important for background rendering)
    await page.setViewport({ width: 1280, height: 1800 });

    // ‚úÖ Set HTML with inline style support
    await page.setContent(html, { waitUntil: ['domcontentloaded', 'networkidle0'] });

    // ‚úÖ Force media emulation and background rendering
    await page.emulateMediaType('screen');

    // ‚úÖ Wait a short time to ensure all styles are applied
    await new Promise(resolve => setTimeout(resolve, 500));

    // ‚úÖ Generate PDF with background colors, gradients, and exact styles
    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
      preferCSSPageSize: true,
    //  margin: { top: '20px', right: '20px', bottom: '20px', left: '20px' },
    });

    console.log('‚úÖ Styled PDF generated successfully');
    return pdfBuffer;
  } catch (error) {
    console.error('‚ùå Error generating styled PDF:', error);
    throw error;
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}


  /**
   * Upload file to DigitalOcean Spaces
   */
  private async uploadToSpaces(fileName: string, fileBuffer: Buffer): Promise<void> {
    try {
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: fileName,
        Body: fileBuffer,
        ContentType: 'application/pdf',
        ACL: 'public-read'
      });

      await this.s3Client.send(command);
      console.log('‚úÖ File uploaded to Spaces:', fileName);
    } catch (error) {
      console.error('‚ùå Error uploading to Spaces:', error);
      throw error;
    }
  }

  /**
   * Upload profile image to DigitalOcean Spaces
   * @param userId - User ID
   * @param fileBuffer - Image file buffer
   * @param fileName - Original file name (for extension)
   * @returns Profile URL or error
   */
  async uploadProfileImage(userId: string, fileBuffer: Buffer, fileName: string): Promise<{
    status: string;
    message: string;
    profileUrl?: string;
    error?: any;
  }> {
    try {
      console.log('üì∏ Starting profile image upload for user:', userId);

      // Validate file
      if (!fileBuffer || fileBuffer.length === 0) {
        return {
          status: 'error',
          message: 'File buffer is empty',
          error: { code: 'EMPTY_FILE' }
        };
      }

      // Validate file size (max 5MB)
      const maxFileSize = 5 * 1024 * 1024; // 5MB
      if (fileBuffer.length > maxFileSize) {
        return {
          status: 'error',
          message: 'File size exceeds 5MB limit',
          error: { code: 'FILE_TOO_LARGE' }
        };
      }

      // Get file extension
      const fileExtension = fileName.split('.').pop()?.toLowerCase() || 'jpg';
      const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];

      if (!allowedExtensions.includes(fileExtension)) {
        return {
          status: 'error',
          message: `Invalid file type. Allowed types: ${allowedExtensions.join(', ')}`,
          error: { code: 'INVALID_FILE_TYPE' }
        };
      }

      // Generate unique file name
      const profileId = uuidv4();
      const uploadFileName = `ProfileImages/${userId}/${profileId}.${fileExtension}`;
      const profileUrl = `${this.spacesEndpoint}/${this.bucketName}/${uploadFileName}`;

      // Determine content type
      const contentTypeMap: { [key: string]: string } = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'webp': 'image/webp'
      };
      const contentType = contentTypeMap[fileExtension] || 'image/jpeg';

      // Upload to DigitalOcean Spaces
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: uploadFileName,
        Body: fileBuffer,
        ContentType: contentType,
        ACL: 'public-read'
      });

      await this.s3Client.send(command);
      console.log('‚úÖ Profile image uploaded successfully to:', profileUrl);

      // Update user profile URL in database
      await this.userModel.findByIdAndUpdate(
        userId,
        { profileUrl: profileUrl },
        { new: true }
      );

      console.log('‚úÖ Profile URL stored in user document');

      return {
        status: 'success',
        message: 'Profile image uploaded successfully',
        profileUrl: profileUrl
      };

    } catch (error) {
      console.error('‚ùå Error uploading profile image:', error);
      return {
        status: 'error',
        message: 'Failed to upload profile image',
        error: {
          code: 'PROFILE_UPLOAD_ERROR',
          details: error.message
        }
      };
    }
  }
    async adminuploadProfileImage(userId: string, fileBuffer: Buffer, fileName: string): Promise<{
    status: string;
    message: string;
    profileUrl?: string;
    error?: any;
  }> {
    try {
      console.log('üì∏ Starting profile image upload for user:', userId);

      // Validate file
      if (!fileBuffer || fileBuffer.length === 0) {
        return {
          status: 'error',
          message: 'File buffer is empty',
          error: { code: 'EMPTY_FILE' }
        };
      }

      // Validate file size (max 5MB)
      const maxFileSize = 5 * 1024 * 1024; // 5MB
      if (fileBuffer.length > maxFileSize) {
        return {
          status: 'error',
          message: 'File size exceeds 5MB limit',
          error: { code: 'FILE_TOO_LARGE' }
        };
      }

      // Get file extension
      const fileExtension = fileName.split('.').pop()?.toLowerCase() || 'jpg';
      const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];

      if (!allowedExtensions.includes(fileExtension)) {
        return {
          status: 'error',
          message: `Invalid file type. Allowed types: ${allowedExtensions.join(', ')}`,
          error: { code: 'INVALID_FILE_TYPE' }
        };
      }

      // Generate unique file name
      const profileId = uuidv4();
      const uploadFileName = `ProfileImages/${userId}/${profileId}.${fileExtension}`;
      const profileUrl = `${this.spacesEndpoint}/${this.bucketName}/${uploadFileName}`;

      // Determine content type
      const contentTypeMap: { [key: string]: string } = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'webp': 'image/webp'
      };
      const contentType = contentTypeMap[fileExtension] || 'image/jpeg';

      // Upload to DigitalOcean Spaces
      const command = new PutObjectCommand({
        Bucket: this.bucketName,
        Key: uploadFileName,
        Body: fileBuffer,
        ContentType: contentType,
        ACL: 'public-read'
      });

      await this.s3Client.send(command);
      console.log('‚úÖ Profile image uploaded successfully to:', profileUrl);

      // Update user profile URL in database
      await this.adminModel.findByIdAndUpdate(
        userId,
        { profileUrl: profileUrl },
        { new: true }
      );

      console.log('‚úÖ Profile URL stored in user document');

      return {
        status: 'success',
        message: 'Profile image uploaded successfully',
        profileUrl: profileUrl
      };

    } catch (error) {
      console.error('‚ùå Error uploading profile image:', error);
      return {
        status: 'error',
        message: 'Failed to upload profile image',
        error: {
          code: 'PROFILE_UPLOAD_ERROR',
          details: error.message
        }
      };
    }
  }

  

}