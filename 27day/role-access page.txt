/* eslint-disable @typescript-eslint/no-explicit-any */
"use client";

import React, { useMemo, useState, useEffect, useCallback } from "react";
import {
  Box,
  Button,
  Typography,
  Paper,
  Tabs,
  Tab,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Tooltip,
  Divider,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Checkbox,
  FormControlLabel,
  CircularProgress,
} from "@mui/material";
import { AddOutlined, Edit, Delete as DeleteIcon } from "@mui/icons-material";
import DashboardLayout from "../../components/layout/DashboardLayout";
import { CustomPagination } from "@frontend/shared-ui";
import { useMutation, useQuery, useApolloClient, useLazyQuery } from "@apollo/client";
import {
  GET_ALL_ROLES,
  CREATE_ROLE_MUTATION,
  UPDATE_ROLE_MUTATION,
  DELETE_ROLE_MUTATION,
  GET_ROLE_BY_ID,
  GET_ROLE,
  UPDATE_ROLE_AND_PERMISSIONS_MUTATION,
  GET_MODULES
} from "../../graphql/role.service";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { withPageLoader } from "@frontend/shared-ui";
import { useDispatch } from "react-redux";
import { setRoleData } from "../../store/roleSlice";

type Role = { id: string; name: string; description?: string; slug?: string };
type PermissionKey = "create" | "read" | "update" | "delete";
type ModuleDef = { key: string; label: string };

const gradientButtonSx = {
  background: "linear-gradient(90deg, #408bff 0%, #3a7de6 100%)",
  textTransform: "none",
  letterSpacing: "0.5px",
  fontWeight: 500,
  fontFamily: "var(--font-inter), sans-serif",
  borderRadius: "4px",
  padding: "8px 24px",
  boxShadow: "0 2px 8px rgba(64, 139, 255, 0.25)",
  "&:hover": {
    background: "linear-gradient(90deg, #3a7de6 0%, #3670cc 100%)",
    boxShadow: "0 4px 12px rgba(64, 139, 255, 0.3)",
  },
};

const headerCellSx = {
  backgroundColor: "#f3f7ff",
  color: "#1f2937",
  fontWeight: 700,
  borderBottom: "1px solid #e6ecf5",
};

function BorderedCheckbox(props: React.ComponentProps<typeof Checkbox>) {
  const Unchecked = (
    <span
      style={{
        width: 18,
        height: 18,
        border: "1.5px solid #000",
        borderRadius: 3,
        display: "inline-block",
        background: "#fff",
      }}
    />
  );
  const Checked = (
    <span
      style={{
        width: 18,
        height: 18,
        borderRadius: 3,
        display: "inline-block",
        background: "#3a7de6",
        position: "relative",
        boxShadow: "inset 0 0 0 1.5px #3a7de6",
      }}
    >
      <svg
        viewBox="0 0 24 24"
        style={{
          position: "absolute",
          inset: 0,
          margin: "auto",
          width: 18,
          height: 18,
          fill: "none",
          stroke: "white",
          strokeWidth: 3,
        }}
      >
        <polyline points="20 6 9 17 4 12" />
      </svg>
    </span>
  );
  return <Checkbox disableRipple color="default" icon={Unchecked} checkedIcon={Checked} {...props} sx={{ p: 0.5 }} />;
}

const RolesAccessPage: React.FC = () => {
  const [tab, setTab] = useState(0);
  const client = useApolloClient();
  const dispatch = useDispatch();

  // Pagination state for roles
  const [currentPage, setCurrentPage] = useState(1);
  const [limit, setLimit] = useState(10);
  const [pagination, setPagination] = useState({
    currentPage: 1,
    totalPages: 1,
    totalCount: 0,
    hasNextPage: false,
    hasPreviousPage: false,
    limit: 10,
  });

  // Pagination state for modules
  const [modulesCurrentPage, setModulesCurrentPage] = useState(1);
  const [modulesLimit, setModulesLimit] = useState(10);
  const [modulesPagination, setModulesPagination] = useState({
    currentPage: 1,
    totalPages: 1,
    totalCount: 0,
    hasNextPage: false,
    hasPreviousPage: false,
    limit: 10,
  });

  // roles from API only
  const [roles, setRoles] = useState<Role[]>([]);
  const [allRolesForDropdown, setAllRolesForDropdown] = useState<Role[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<any>(null);
  const [modulesError, setModulesError] = useState<any>(null);
  
  // Use lazy query for better control over when to fetch
  const [fetchRoles, { data, refetch }] = useLazyQuery(GET_ALL_ROLES, {
    fetchPolicy: "network-only",
    errorPolicy: "all",
    onCompleted: (data) => {
      // Query completed successfully
    },
    onError: (error) => {
      setError(error);
    }
  });

  // Modules lazy query
  const [fetchModules, { data: modulesData, refetch: refetchModules }] = useLazyQuery(GET_MODULES, {
    fetchPolicy: "network-only",
    errorPolicy: "all",
    onCompleted: (data) => {
      // Modules query completed successfully
    },
    onError: (error) => {
      setModulesError(error);
    }
  });

  useEffect(() => {
    const payload = (data as any)?.listAllRoles;
    if (payload?.status === "success" && Array.isArray(payload?.data)) {
      const mapped: Role[] = payload.data.map((r: any) => ({
        id: r?._id ?? "",
        name: r?.roleName ?? "",
        description: r?.description ?? "",
        slug: r?.roleslug ?? "",
      }));
      setRoles(mapped);
      
      // Update pagination state
      if (payload?.pagination) {
        setPagination({
          currentPage: payload.pagination.currentPage || 1,
          totalPages: payload.pagination.totalPages || 1,
          totalCount: payload.pagination.totalCount || 0,
          hasNextPage: payload.pagination.hasNextPage || false,
          hasPreviousPage: payload.pagination.hasPreviousPage || false,
          limit: payload.pagination.limit || 10,
        });
      }
    }
  }, [data]);

  // Fetch data on component mount and when pagination changes
  useEffect(() => {
    setLoading(true);
    fetchRoles({
      variables: { page: currentPage, limit }
    }).finally(() => {
      setLoading(false);
    });
  }, [currentPage, limit, fetchRoles]);

  useEffect(() => {
    if (error) console.error("Failed to fetch roles:", error);
  }, [error]);

  // Process modules data
  useEffect(() => {
    const payload = (modulesData as any)?.getModules;
    if (payload?.status === "success" && Array.isArray(payload?.data)) {
      setModulesList(payload.data);
      
      // Update modules pagination state
      if (payload?.pagination) {
        setModulesPagination({
          currentPage: payload.pagination.currentPage || 1,
          totalPages: payload.pagination.totalPages || 1,
          totalCount: payload.pagination.totalCount || 0,
          hasNextPage: payload.pagination.hasNextPage || false,
          hasPreviousPage: payload.pagination.hasPreviousPage || false,
          limit: payload.pagination.limit || 10,
        });
      }
    }
  }, [modulesData]);

  useEffect(() => {
    if (modulesError) console.error("Failed to fetch modules:", modulesError);
  }, [modulesError]);


  // Extract modules from listAllRoles response
  const modules: ModuleDef[] = useMemo(() => {
    const payload = (data as any)?.listAllRoles;
    if (payload?.status === "success" && Array.isArray(payload?.data)) {
      // Extract all unique modules from all roles
      const allModules = new Map<string, ModuleDef>();
      
      payload.data.forEach((role: any) => {
        if (Array.isArray(role?.modules)) {
          role.modules.forEach((module: any) => {
            if (module?.name && module?.slug) {
              const key = module.slug;
              const label = module.name;
              if (!allModules.has(key)) {
                allModules.set(key, { key, label });
              }
            }
          });
        }
      });

      return Array.from(allModules.values());
    }

    return [];
  }, [data]);

  // Initially populate modules from listAllRoles for Super Admin
  useEffect(() => {
    const payload = (data as any)?.listAllRoles;
    if (payload?.status === "success" && Array.isArray(payload?.data)) {
      const superAdmin = payload.data.find((role: any) => 
        role?.roleName?.trim().toLowerCase() === "super admin"
      );
      if (superAdmin?.modules) {
        setSelectedRoleModules(superAdmin.modules);
      }
    }
  }, [data]);


  // dialog + form
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingRole, setEditingRole] = useState<Role | null>(null);
  const [formName, setFormName] = useState("");
  const [formDesc, setFormDesc] = useState("");

  // Access Rights tab state
  const [selectedRoleModules, setSelectedRoleModules] = useState<any[]>([]);
  const [loadingRoleModules, setLoadingRoleModules] = useState(false);
  
  // Modules state for Access Rights tab
  const [modulesList, setModulesList] = useState<any[]>([]);
  const [allModulesForUpdate, setAllModulesForUpdate] = useState<any[]>([]); // Store all modules for updates
  const [modulesLoading, setModulesLoading] = useState(false);

  const [createRole, { loading: createLoading }] = useMutation(CREATE_ROLE_MUTATION);
  const [updateRole, { loading: updateLoading }] = useMutation(UPDATE_ROLE_MUTATION);
  const [deleteRole, { loading: deleteLoading }] = useMutation(DELETE_ROLE_MUTATION);
  const [updateRoleAndPermissions, { loading: updatePermissionsLoading }] = useMutation(UPDATE_ROLE_AND_PERMISSIONS_MUTATION);

  // Pagination handlers
  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  const handleRowsPerPageChange = (newLimit: number) => {
    setLimit(newLimit);
    setCurrentPage(1); // Reset to first page when changing limit
  };

  // Modules pagination handlers
  const handleModulesPageChange = (page: number) => {
    setModulesCurrentPage(page);
  };

  const handleModulesRowsPerPageChange = (newLimit: number) => {
    setModulesLimit(newLimit);
    setModulesCurrentPage(1); // Reset to first page when changing limit
  };

  const refetchWithPagination = async () => {
    setLoading(true);
    await fetchRoles({
      variables: { page: currentPage, limit }
    }).finally(() => {
      setLoading(false);
    });
  };

  const refetchAllData = async () => {
    // Refetch both roles and modules
    await Promise.all([
      refetchWithPagination(),
      refetchModulesWithPagination(),
      refetchAllModules(), // Refetch all modules for updates
      fetchAllRolesForDropdown() // Also refetch all roles for dropdown
    ]);
  };

  // Fetch modules on component mount and when modules pagination changes
  useEffect(() => {
    setModulesLoading(true);
    fetchModules({
      variables: { page: modulesCurrentPage, limit: modulesLimit }
    }).finally(() => {
      setModulesLoading(false);
    });
  }, [modulesCurrentPage, modulesLimit, fetchModules]);

  // Fetch ALL modules for updates when component mounts (separate from pagination)
  useEffect(() => {
    const fetchAllModules = async () => {
      try {
        const { data } = await client.query({
          query: GET_MODULES,
          variables: { page: 1, limit: 1000 }, // Fetch all modules at once
          fetchPolicy: "network-only",
        });
        
        const payload = data?.getModules;
        if (payload?.status === "success" && Array.isArray(payload?.data)) {
          setAllModulesForUpdate(payload.data);
          console.log('üîç Fetched all modules for updates:', payload.data);
        }
      } catch (error) {
        console.error("Failed to fetch all modules:", error);
      }
    };

    fetchAllModules();
  }, [client]);

  // Fetch modules and all roles when switching to Access Rights tab
  useEffect(() => {
    if (tab === 1) {
      // Fetch all roles for dropdown
      fetchAllRolesForDropdown();
      
      // Fetch modules if not already loaded
      if (modulesList.length === 0) {
        setModulesLoading(true);
        fetchModules({
          variables: { page: modulesCurrentPage, limit: modulesLimit }
        }).finally(() => {
          setModulesLoading(false);
        });
      }
    }
  }, [tab, modulesList.length, fetchModules, modulesCurrentPage, modulesLimit]);

  const refetchModulesWithPagination = async () => {
    setModulesLoading(true);
    await fetchModules({
      variables: { page: modulesCurrentPage, limit: modulesLimit }
    }).finally(() => {
      setModulesLoading(false);
    });
  };

  const refetchAllModules = async () => {
    try {
      const { data } = await client.query({
        query: GET_MODULES,
        variables: { page: 1, limit: 1000 }, // Fetch all modules at once
        fetchPolicy: "network-only",
      });
      
      const payload = data?.getModules;
      if (payload?.status === "success" && Array.isArray(payload?.data)) {
        setAllModulesForUpdate(payload.data);
        console.log('üîç Refetched all modules for updates:', payload.data);
      }
    } catch (error) {
      console.error("Failed to refetch all modules:", error);
    }
  };

  // Function to fetch all roles for dropdown (with high limit)
  const fetchAllRolesForDropdown = async () => {
    try {
      const { data } = await client.query({
        query: GET_ALL_ROLES,
        variables: { page: 1, limit: 1000 }, // High limit to get all roles
        fetchPolicy: "network-only",
      });
      
      const payload = data?.listAllRoles;
      if (payload?.status === "success" && Array.isArray(payload?.data)) {
        const allRoles = payload.data.map((role: any) => ({
          id: role._id,
          name: role.roleName,
          description: role.description,
          slug: role.roleslug
        }));
        setAllRolesForDropdown(allRoles);
      }
    } catch (error) {
      console.error("Failed to fetch all roles for dropdown:", error);
    }
  };

  // Function to fetch role by ID
  const fetchRoleById = async (roleId: string) => {
    try {
      const { data } = await client.query({
        query: GET_ROLE_BY_ID,
        variables: { roleId },
        fetchPolicy: "network-only",
      });
      return data;
    } catch (error) {
      console.error("Failed to fetch role by ID:", error);
      throw error;
    }
  };

  // Function to fetch role-specific modules
  const fetchRoleModules = useCallback(async (roleslug: string, roleId?: string) => {
    setLoadingRoleModules(true);
    try {
      const { data } = await client.query({
        query: GET_ROLE,
        variables: { roleslug },
        fetchPolicy: "network-only",
      });
      
      const roleData = data?.getRole?.data;
      if (roleData?.modules) {
        setSelectedRoleModules(roleData.modules);
        
        // Update permissions state with API data
        if (roleId) {
          setPermissions(prev => {
            const updated = { ...prev };
            updated[roleId] = {};
            
            // If modules array is empty, initialize with all modules from getModules
            if (roleData.modules.length === 0) {
              // Use allModulesForUpdate (from getModules API) to initialize permissions
              allModulesForUpdate.forEach((module: any) => {
                const moduleKey = module.slug;
                updated[roleId][moduleKey] = {
                  create: module.permissions?.create || false,
                  read: module.permissions?.view || false, // Map 'view' to 'read'
                  update: module.permissions?.update || false,
                  delete: module.permissions?.delete || false
                };
              });
            } else {
              // Use existing modules data
              roleData.modules.forEach((module: any) => {
                const moduleKey = module.slug;
                updated[roleId][moduleKey] = {
                  create: module.permissions?.create || false,
                  read: module.permissions?.view || false, // Map 'view' to 'read'
                  update: module.permissions?.update || false,
                  delete: module.permissions?.delete || false
                };
              });
            }
            
            return updated;
          });
        }
      } else {
        setSelectedRoleModules([]);
        // Initialize permissions for empty modules
        if (roleId) {
          setPermissions(prev => {
            const updated = { ...prev };
            updated[roleId] = {};
            
            // Use allModulesForUpdate to initialize permissions with default values from getModules
            allModulesForUpdate.forEach((module: any) => {
              const moduleKey = module.slug;
              updated[roleId][moduleKey] = {
                create: module.permissions?.create || false,
                read: module.permissions?.view || false, // Map 'view' to 'read'
                update: module.permissions?.update || false,
                delete: module.permissions?.delete || false
              };
            });
            
            return updated;
          });
        }
      }
    } catch (error) {
      console.error("Failed to fetch role modules:", error);
      toast.error("Failed to load role modules");
      setSelectedRoleModules([]);
    } finally {
      setLoadingRoleModules(false);
    }
  }, [client, allModulesForUpdate]);

  // delete dialog
  const [deleteOpen, setDeleteOpen] = useState(false);
  const [roleToDelete, setRoleToDelete] = useState<Role | null>(null);

  const openAdd = () => {
    setEditingRole(null);
    setFormName("");
    setFormDesc("");
    setDialogOpen(true);
  };
  const openEdit = async (role: Role) => {
    try {
      // Fetch fresh role data using getRoleById API
      const roleData = await fetchRoleById(role.id);
      const freshRole = roleData?.getRoleById?.data;
      
      if (freshRole) {
        setEditingRole({
          id: freshRole._id,
          name: freshRole.roleName,
          description: freshRole.description || ""
        });
        setFormName(freshRole.roleName);
        setFormDesc(freshRole.description || "");
        setDialogOpen(true);
      } else {
        // Fallback to existing role data if API fails
        setEditingRole(role);
        setFormName(role.name);
        setFormDesc(role.description || "");
        setDialogOpen(true);
        toast.warning("Using cached data - some information may be outdated");
      }
    } catch (error) {
      console.error("Failed to fetch role details:", error);
      // Fallback to existing role data
      setEditingRole(role);
      setFormName(role.name);
      setFormDesc(role.description || "");
      setDialogOpen(true);
      toast.error("Failed to load role details, using cached data");
    }
  };

  const saveRole = async () => {
    if (!formName.trim()) {
      toast.error("Role name is required");
      return;
    }

    if (editingRole) {
      try {
        const { data } = await updateRole({
          variables: {
            input: { 
              roleId: editingRole.id,
              roleName: formName.trim(), 
              description: formDesc.trim() 
            },
          },
          context: { operationName: "UpdateRole" },
        });

        const result = (data as any)?.updateRole;
        if (!result) throw new Error("No response from server");
        if (result.status === "success") {
          toast.success(result.message || "Role updated successfully");
          setDialogOpen(false);
          await refetchAllData();
        } else {
          const errorMessage = result.message || result.error?.message || "Failed to update role";
          toast.error(errorMessage);
          return;
        }
      } catch (e: any) {
        console.error(e);
        toast.error(e?.message ?? "Something went wrong");
      }
      return;
    }

    try {
      const { data } = await createRole({
        variables: { input: { roleName: formName.trim(), description: formDesc.trim() } },
        context: { operationName: "CreateRole" },
      });

      const result = (data as any)?.createRole;
      if (!result) throw new Error("No response from server");

      if (result.status === "success") {
        toast.success(result.message || "Role created successfully");
        setDialogOpen(false);
        await refetchAllData();
      } else {
        const errorMessage = result.message || result.error?.message || "Failed to create role";
        toast.error(errorMessage);
        return;
      }
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message ?? "Something went wrong");
    }
  };

  const openDelete = (role: Role) => {
    setRoleToDelete(role);
    setDeleteOpen(true);
  };

  const confirmDelete = async () => {
    if (!roleToDelete) return;
    try {
      const { data } = await deleteRole({
        variables: { roleId: roleToDelete.id },
        context: { operationName: "DeleteRole" },
      });

      const result = (data as any)?.deleteRole;
      if (!result) throw new Error("No response from server");
      if (result.status === "success") {
        toast.success(result.message || "Role deleted successfully");
        setDeleteOpen(false);
        setRoleToDelete(null);
        await refetchAllData();
      } else {
        // Handle error response structure
        const errorMessage = result.message || result.error?.message || "Failed to delete role";
        toast.error(errorMessage);
        setDeleteOpen(false);
        setRoleToDelete(null);
      }
    } catch (e: any) {
      console.error(e);
      toast.error(e?.message ?? "Something went wrong");
    }
  };

  // access rights
  // ‚ñº default active role: super_admin if present, else first
  const [activeRoleId, setActiveRoleId] = useState<string>("");
  useEffect(() => {
    // Use allRolesForDropdown for role selection if available, otherwise fall back to roles
    const rolesToUse = allRolesForDropdown.length > 0 ? allRolesForDropdown : roles;
    if (!rolesToUse.length) return;
    const currentExists = activeRoleId && rolesToUse.some((r) => r.id === activeRoleId);
    if (!currentExists) {
      const superAdmin = rolesToUse.find((r) => r.name?.trim().toLowerCase() === "super admin");
      if (superAdmin) {
        setActiveRoleId(superAdmin.id);
        // Fetch Super Admin modules immediately
        fetchRoleModules(superAdmin.slug || superAdmin.name, superAdmin.id);
      } else {
        setActiveRoleId(rolesToUse[0].id);
        // Fetch first role modules
        fetchRoleModules(rolesToUse[0].slug || rolesToUse[0].name, rolesToUse[0].id);
      }
    }
  }, [allRolesForDropdown, roles, activeRoleId, fetchRoleModules]);

  // Ensure permissions are initialized when activeRoleId changes
  useEffect(() => {
    if (activeRoleId && allModulesForUpdate.length > 0) {
      setPermissions(prev => {
        const updated = { ...prev };
        if (!updated[activeRoleId]) {
          updated[activeRoleId] = {};
        }
        
        // Initialize with all modules using default values from getModules
        // Only initialize if not already set (preserve existing state)
        allModulesForUpdate.forEach((module: any) => {
          const moduleKey = module.slug;
          if (!updated[activeRoleId][moduleKey]) {
            updated[activeRoleId][moduleKey] = {
              create: module.permissions?.create || false,
              read: module.permissions?.view || false, // Map 'view' to 'read'
              update: module.permissions?.update || false,
              delete: module.permissions?.delete || false
            };
          }
        });
        
        return updated;
      });
    }
  }, [activeRoleId, allModulesForUpdate]);


  const [permissions, setPermissions] = useState<Record<string, Record<string, Record<PermissionKey, boolean>>>>({});

  // Initialize permissions for all roles with allModulesForUpdate data
  useEffect(() => {
    const rolesToUse = allRolesForDropdown.length > 0 ? allRolesForDropdown : roles;
    if (rolesToUse.length > 0 && allModulesForUpdate.length > 0) {
      setPermissions((prev) => {
        const next = { ...prev };
        for (const role of rolesToUse) {
          next[role.id] ??= {};
          for (const module of allModulesForUpdate) {
            const moduleKey = module.slug;
            const moduleLabel = module.name;
            const isDashboardModule = moduleLabel?.toLowerCase().includes('dashboard') || moduleKey?.toLowerCase().includes('dashboard');
            
            // Only initialize if not already set (preserve existing state)
            if (!next[role.id][moduleKey]) {
              next[role.id][moduleKey] = {
                create: module.permissions?.create || false,
                read: isDashboardModule ? true : (module.permissions?.view || false), // Dashboard view is checked by default
                update: module.permissions?.update || false,
                delete: module.permissions?.delete || false
              };
            }
          }
        }
        // Clean up permissions for roles that no longer exist
        Object.keys(next).forEach((rid) => {
          if (!rolesToUse.some((r) => r.id === rid)) delete next[rid];
        });
        // Don't clean up modules permissions since we want to preserve state across pages
        return next;
      });
    }
  }, [allRolesForDropdown, roles, allModulesForUpdate]);

  const togglePerm = (roleId: string, moduleKey: string, key: PermissionKey) => {
    setPermissions((p) => {
      // Ensure roleId exists
      const rolePermissions = p[roleId] || {};
      // Ensure moduleKey exists with default permissions
      const modulePermissions = rolePermissions[moduleKey] || { create: false, read: false, update: false, delete: false };
      
      const newValue = !modulePermissions[key];
      let updatedPermissions = { ...modulePermissions, [key]: newValue };
      
      // Rule 1: If any update, delete, create checked then view automatically checked
      if (newValue && (key === 'create' || key === 'update' || key === 'delete')) {
        updatedPermissions.read = true;
      }
      
      // Rule 2: If create checked, then rest all checked
      if (key === 'create' && newValue) {
        updatedPermissions = {
          read: true,
          create: true,
          update: true,
          delete: true
        };
      }
      
      return {
        ...p,
        [roleId]: {
          ...rolePermissions,
          [moduleKey]: updatedPermissions,
        },
      };
    });
    
    // Also update selectedRoleModules if it exists
    setSelectedRoleModules(prev => {
      const updated = [...prev];
      const moduleIndex = updated.findIndex(m => (m.key || m.slug) === moduleKey);
      if (moduleIndex !== -1 && updated[moduleIndex].permissions) {
        const apiKey = key === 'read' ? 'view' : key;
        let newPermissions = {
          ...updated[moduleIndex].permissions,
          [apiKey]: !updated[moduleIndex].permissions[apiKey]
        };
        
        // Apply the same rules to selectedRoleModules
        if (key === 'create' && newPermissions.create) {
          newPermissions = {
            view: true,
            create: true,
            update: true,
            delete: true
          };
        } else if (newPermissions.create || newPermissions.update || newPermissions.delete) {
          newPermissions.view = true;
        }
        
        updated[moduleIndex] = {
          ...updated[moduleIndex],
          permissions: newPermissions
        };
      }
      return updated;
    });
  };

  const saveAccess = async () => {
    if (!activeRoleId) {
      toast.error("Please select a role first");
      return;
    }

    try {
      // Get current permissions for the active role
      const rolePermissions = permissions[activeRoleId] || {};
      
      // Convert permissions to the API format - include ALL modules from all pages
      const modules = allModulesForUpdate.map(moduleData => {
        const moduleKey = moduleData.slug;
        const modulePermissions = rolePermissions[moduleKey] || {
          create: false,
          read: false,
          update: false,
          delete: false
        };
        
        return {
          slug: moduleKey,
          name: moduleData.name,
          permissions: {
            create: modulePermissions.create || false,
            view: modulePermissions.read || false,
            update: modulePermissions.update || false,
            delete: modulePermissions.delete || false
          }
        };
      });

      console.log('üîç saveAccess - All modules for update:', allModulesForUpdate);
      console.log('üîç saveAccess - All modules count:', allModulesForUpdate.length);
      console.log('üîç saveAccess - Role permissions:', rolePermissions);
      console.log('üîç saveAccess - Modules being sent to API:', modules);
      console.log('üîç saveAccess - Modules count being sent:', modules.length);
      
      // Check if Transactions module is included
      const hasTransactions = modules.some(m => m.slug === 'transactions');
      console.log('üîç saveAccess - Has Transactions module:', hasTransactions);

      const { data } = await updateRoleAndPermissions({
        variables: {
          input: {
            roleId: activeRoleId,
            modules: modules
          }
        }
      });

      const result = data?.updateRoleAndPermissions;
      if (result?.statusCode === 200) {
        toast.success(result.message || "Permissions updated successfully");
        // Refresh both role modules and general modules data
        const selectedRole = roles.find(role => role.id === activeRoleId);
        if (selectedRole) {
          await Promise.all([
            fetchRoleModules(selectedRole.slug || selectedRole.name, selectedRole.id),
            refetchModulesWithPagination(),
            refetchAllModules() // Refresh all modules for updates
          ]);
          
          // Refresh Redux store with updated role data
          try {
            const { data: updatedRoleData } = await client.query({
              query: GET_ROLE,
              variables: { roleslug: selectedRole.slug || selectedRole.name },
              fetchPolicy: "network-only",
            });
            
            if (updatedRoleData?.getRole?.data) {
              dispatch(setRoleData(updatedRoleData.getRole.data));
              console.log('üîç Redux store updated with new role data:', updatedRoleData.getRole.data);
            }
          } catch (error) {
            console.error("Failed to refresh Redux store:", error);
          }
        }
      } else {
        toast.error(result?.message || "Failed to update permissions");
      }
    } catch (error: any) {
      console.error("Failed to save permissions:", error);
      toast.error(error.message || "Failed to update permissions");
    }
  };

  return (
    <DashboardLayout>
      <Box>
        {/* Header */}
        <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 3, px: { xs: 0.5, md: 1 } }}>
          <Box>
            <Typography variant="h5" fontWeight={700} sx={{ fontFamily: "var(--font-inter), sans-serif" }}>
              Roles & Access
            </Typography>
            <Typography variant="subtitle1" color="#6c757d" sx={{ fontFamily: "var(--font-inter), sans-serif" }}>
              Manage roles and set access permissions
            </Typography>
          </Box>
          {tab === 0 && (
            <Button onClick={openAdd} variant="contained" size="large" sx={gradientButtonSx}>
              <AddOutlined sx={{ mr: 1 }} />
              Add New Role
            </Button>
          )}
        </Box>

        <Paper sx={{ borderRadius: "12px", p: { xs: 1.5, md: 2 }, pt: 2 }}>
          {/* Tabs */}
          <Tabs
            value={tab}
            onChange={(_, v) => setTab(v)}
            sx={{
              px: 1,
              "& .MuiTab-root": {
                textTransform: "none",
                fontWeight: 600,
                mr: 2,
                color: "#6b6b6b",
                "&.Mui-selected": { color: "#000", backgroundColor: "#f5f9ff", borderRadius: "8px 8px 0 0", fontWeight: 700 },
              },
              "& .MuiTabs-indicator": { height: 3, borderRadius: 2, backgroundColor: "#3a7de6" },
            }}
          >
            <Tab label="Roles" />
            <Tab label="Access Rights" />
          </Tabs>

          <Divider sx={{ mt: 1, mb: 2 }} />

          {/* ROLES */}
          {tab === 0 && (
            <Box sx={{ overflowX: "auto", px: { xs: 0.5, md: 1 } }}>
              {loading ? (
                <Box sx={{ display: "flex", justifyContent: "center", py: 6 }}>
                  <CircularProgress />
                </Box>
              ) : (
                <Table sx={{ width: "100%" }}>
                  <TableHead>
                    <TableRow>
                      <TableCell sx={headerCellSx} width={80}>
                        S.No
                      </TableCell>
                      <TableCell sx={headerCellSx}>Role Name</TableCell>
                      <TableCell sx={headerCellSx}>Description</TableCell>
                      <TableCell sx={{ ...headerCellSx, textAlign: "right" }} width={160}>
                        Actions
                      </TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {roles.length === 0 ? (
                      <TableRow>
                        <TableCell colSpan={4} align="center" sx={{ py: 4 }}>
                          <Typography variant="h6" color="#6c757d" fontWeight={600}>
                            No Record Found
                          </Typography>
                        </TableCell>
                      </TableRow>
                    ) : (
                      roles.map((role, idx) => (
                        <TableRow key={role.id} sx={{ backgroundColor: idx % 2 ? "#f5f5f5" : "#fff", "& td": { borderBottom: "1px solid #eef2f7" } }}>
                          <TableCell>{(currentPage - 1) * limit + idx + 1}</TableCell>
                          <TableCell sx={{ fontWeight: 600 }}>{role.name}</TableCell>
                          <TableCell sx={{ color: "#6b7280" }}>{role.description || "No description"}</TableCell>
                          <TableCell sx={{ textAlign: "right" }}>
                            <Tooltip title="Edit">
                              <IconButton onClick={() => openEdit(role)}>
                                <Edit style={{ fontSize: 25, color: "#408bff" }} />
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="Delete">
                              <IconButton onClick={() => openDelete(role)} disabled={deleteLoading}>
                                <DeleteIcon style={{ fontSize: 25, color: "#e53935" }} />
                              </IconButton>
                            </Tooltip>
                          </TableCell>
                        </TableRow>
                      ))
                    )}
                  </TableBody>
                </Table>
              )}
              
              {/* Pagination Component */}
              {!loading && roles.length > 0 && (
                <CustomPagination
                  currentPage={pagination.currentPage}
                  totalPages={pagination.totalPages}
                  rowsPerPage={pagination.limit}
                  totalItems={pagination.totalCount}
                  onPageChange={handlePageChange}
                  onRowsPerPageChange={handleRowsPerPageChange}
                  rowsPerPageOptions={[5, 10, 25, 50, 100]}
                />
              )}
            </Box>
          )}

          {/* ACCESS RIGHTS */}
          {tab === 1 && (
            <Box sx={{ px: { xs: 0.5, md: 1 } }}>
              <Box sx={{ display: "flex", alignItems: "center", gap: 2, my: 3 }}>
                <FormControl sx={{ minWidth: 260 }}>
                  <InputLabel>Select Role</InputLabel>
                  <Select
                    label="Select Role"
                    value={activeRoleId || ""}
                    onChange={(e) => {
                      const selectedRoleId = String(e.target.value);
                      setActiveRoleId(selectedRoleId);
                      // Find the role name to use as identifier
                      const rolesToUse = allRolesForDropdown.length > 0 ? allRolesForDropdown : roles;
                      const selectedRole = rolesToUse.find(role => role.id === selectedRoleId);
                      if (selectedRole) {
                        // Use roleName as identifier for the API call
                        fetchRoleModules(selectedRole.slug || selectedRole.name, selectedRole.id);
                      }
                    }}
                    // size="small"
                    disabled={loading || (allRolesForDropdown.length === 0 && roles.length === 0)}
                    sx={{
                      // height: 45,
                      backgroundColor: "#fff",
                      boxShadow: "0 1px 2px rgba(16,24,40,0.04)",
                      "& .MuiOutlinedInput-notchedOutline": { borderColor: "#e6ecf5" },
                      "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "#cfd7e6" },
                      "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#408bff" },
                    }}
                  >
                    {(allRolesForDropdown.length > 0 ? allRolesForDropdown : roles).map((r) => (
                      <MenuItem key={r.id} value={r.id}>
                        {r.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Box>

              <Table sx={{ width: "100%" }}>
                <TableHead>
                  <TableRow>
                    <TableCell sx={{ ...headerCellSx, width: 320 }}>Module</TableCell>
                    <TableCell sx={headerCellSx} align="center">
                      View
                    </TableCell>
                    <TableCell sx={headerCellSx} align="center">
                      Create
                    </TableCell>
                    <TableCell sx={headerCellSx} align="center">
                      Update
                    </TableCell>
                    <TableCell sx={headerCellSx} align="center">
                      Delete
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {loadingRoleModules || modulesLoading ? (
                    <TableRow>
                      <TableCell colSpan={5} align="center" sx={{ py: 4 }}>
                        <CircularProgress size={40} />
                      </TableCell>
                    </TableRow>
                  ) : modulesList.map((m, i) => {
                    // Handle different data structures
                    const moduleKey = m.slug;
                    const moduleLabel = m.name;
                    
                    // Check if this is Dashboard module
                    const isDashboardModule = moduleLabel?.toLowerCase().includes('dashboard') || moduleKey?.toLowerCase().includes('dashboard');
                    
                    return (
                    <TableRow key={moduleKey} sx={{ backgroundColor: i % 2 ? "#f5f5f5" : "#fff", "& td": { borderBottom: "1px solid #eef2f7" } }}>
                      <TableCell sx={{ fontWeight: 600 }}>{moduleLabel}</TableCell>
                      {(["read", "create", "update", "delete"] as PermissionKey[]).map((k) => {
                        // Hide Create, Update, Delete for Dashboard module
                        if (isDashboardModule && k !== 'read') {
                          return (
                            <TableCell key={`${moduleKey}-${k}`} align="center">
                              <Box sx={{ width: 24, height: 24 }} /> {/* Empty space to maintain table structure */}
                            </TableCell>
                          );
                        }
                        
                        // Use permissions state for interactive checkboxes
                        const isChecked = Boolean(permissions[activeRoleId]?.[moduleKey]?.[k] || false);
                        
                        return (
                          <TableCell key={`${moduleKey}-${k}`} align="center">
                            <FormControlLabel
                              sx={{ m: 0 }}
                              control={
                                <BorderedCheckbox
                                  checked={isChecked}
                                  onChange={() => togglePerm(activeRoleId, moduleKey, k)}
                                />
                              }
                              label=""
                            />
                          </TableCell>
                        );
                      })}
                    </TableRow>
                    );
                  })}
                </TableBody>
              </Table>

              {/* Modules Pagination Component */}
              {!modulesLoading && modulesList.length > 0 && (
                <CustomPagination
                  currentPage={modulesPagination.currentPage}
                  totalPages={modulesPagination.totalPages}
                  rowsPerPage={modulesPagination.limit}
                  totalItems={modulesPagination.totalCount}
                  onPageChange={handleModulesPageChange}
                  onRowsPerPageChange={handleModulesRowsPerPageChange}
                  rowsPerPageOptions={[5, 10, 25, 50, 100]}
                />
              )}

              <Box sx={{ display: "flex", justifyContent: "center", mt: 5, pb: 2 }}>
                <Button 
                  variant="contained" 
                  sx={gradientButtonSx} 
                  onClick={saveAccess}
                  disabled={updatePermissionsLoading || !activeRoleId}
                >
                  {updatePermissionsLoading ? (
                    <>
                      <CircularProgress size={20} sx={{ mr: 1, color: 'white' }} />
                      Saving...
                    </>
                  ) : (
                    "Save For Changes"
                  )}
                </Button>
              </Box>
            </Box>
          )}
        </Paper>

        {/* Add/Edit Role Dialog */}
        <Dialog open={dialogOpen} onClose={() => !(createLoading || updateLoading) && setDialogOpen(false)} fullWidth maxWidth="sm">
          <DialogTitle sx={{ fontWeight: 700 }}>{editingRole ? "Edit Role" : "Add New Role"}</DialogTitle>
          <DialogContent sx={{ pt: 1 }}>
            <TextField
              fullWidth
              label="Role Name"
              value={formName}
              onChange={(e) => setFormName(e.target.value)}
              sx={{ mt: 1.5 }}
              disabled={createLoading || updateLoading}
            />
            <TextField
              fullWidth
              label="Description"
              value={formDesc}
              onChange={(e) => setFormDesc(e.target.value)}
              sx={{ mt: 2 }}
              multiline
              minRows={2}
              disabled={createLoading || updateLoading}
            />
          </DialogContent>
          <DialogActions sx={{ p: 2 }}>
            <Button
              variant="outlined"
              onClick={() => setDialogOpen(false)}
              disabled={createLoading || updateLoading}
              sx={{
                textTransform: "uppercase",
                fontWeight: 500,
                color: "#408bff",
                borderColor: "#408bff",
                px: 3,
                "&:hover": { backgroundColor: "rgba(64, 139, 255, 0.04)", borderColor: "#408bff" },
              }}
            >
              Cancel
            </Button>
            <Button onClick={saveRole} variant="contained" sx={gradientButtonSx} disabled={createLoading || updateLoading}>
              {createLoading || updateLoading ? (
                <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                  <CircularProgress size={18} />
                  {editingRole ? "Saving" : "Creating"}
                </Box>
              ) : editingRole ? "Save" : "Create"}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Delete Role Dialog */}
        <Dialog open={deleteOpen} onClose={() => !deleteLoading && setDeleteOpen(false)} fullWidth maxWidth="sm">
          <DialogTitle sx={{ fontWeight: 700 }}>Delete Role</DialogTitle>
          <DialogContent sx={{ pt: 1 }}>
            <Typography>
              Are you sure you want to delete the role <strong>{roleToDelete?.name}</strong>?
            </Typography>
          </DialogContent>
          <DialogActions sx={{ p: 2 }}>
            <Button
              variant="outlined"
              onClick={() => setDeleteOpen(false)}
              disabled={deleteLoading}
              sx={{
                textTransform: "uppercase",
                fontWeight: 500,
                color: "#408bff",
                borderColor: "#408bff",
                px: 3,
                "&:hover": { backgroundColor: "rgba(64, 139, 255, 0.04)", borderColor: "#408bff" },
              }}
            >
              Cancel
            </Button>
            <Button variant="contained" color="error" onClick={confirmDelete} disabled={deleteLoading}>
              {deleteLoading ? <CircularProgress size={18} /> : "Delete"}
            </Button>
          </DialogActions>
        </Dialog>
      </Box>
    </DashboardLayout>
  );
};  //test

export default withPageLoader(RolesAccessPage);